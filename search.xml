<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F05%2F07%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[sss]]></title>
    <url>%2F2019%2F05%2F06%2Fsss-2%2F</url>
    <content type="text"><![CDATA[前言配置环境，研究了一整天，踩了很多坑，在网上找了很多资料，发现基本上都没非常明确的教程，所以今天想分享一下配置tensorflow GPU版本的经验，希望能让各位朋友少走些弯路。（PS：一切的前提，你需要有一张Nvidia显卡。我的显卡是 GT940MX） Tensorflow有两个版本：GPU和CPU版本，CPU的很好安装；GPU 版本需要 CUDA 和 cuDNN 的支持，如果你是独显+集显，那么推荐你用GPU版本的，因为GPU对矩阵运算有很好的支持，会加速程序执行！并且CUDA是Nvidia下属的程序，所以你的GPU最好是Nvidia的，AMD的显卡没有CUDA加速！满足以上条件之后，你需要查看一下你的英伟达GPU是否支持CUDA，以下是Geforce支持的目录： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313# -*- coding: utf-8 -*-"""Created on Mon Feb 26 16:06:04 2018数据增强程序@author: John Kwok"""#%%'''第一步：初始化，数据准备'''import GetDataUtilimport numpy as nporiginData = GetDataUtil.saveDataToNP("../DataSet/trim",savePath = "../DataSet_NPSave/DataSet.npy")GetDataUtil.interpolation(originData,sample = 300,kind ="cubic",savePath="../DataSet_NPSave/JustifiedData.npy")# 加载文件justifiedData = np.load("../DataSet_NPSave/JustifiedData.npy")print(len(justifiedData))accelerate_data = []collision_data = []uniform_speed_data = []left_turn_data = []right_turn_data = []# 分离各个动作到数组for data in justifiedData: if data["Label"] == 1: accelerate_data.append(data) elif data["Label"] == 2: collision_data.append(data) elif data["Label"] == 3: uniform_speed_data.append(data) elif data["Label"] == 4: left_turn_data.append(data) elif data["Label"] == 5: right_turn_data.append(data)# 转换为numpyaccelerate_data = np.array(accelerate_data)collision_data = np.array(collision_data)uniform_speed_data = np.array(uniform_speed_data)left_turn_data = np.array(left_turn_data)right_turn_data = np.array(right_turn_data)print(accelerate_data.shape)print(collision_data.shape)print(uniform_speed_data.shape)print(left_turn_data.shape)print(right_turn_data.shape)#%%'''算法一：基于非主特征轴加权融合数据增强算法'''def DataArgument_1(rawData,label,expNum=500,weight=0.8,savePath="../DataSet_NPSave/AugmentatedData"): AugmentatedData = [] rawLenth = len(rawData) augNum = expNum - rawLenth Labels = ["加速","碰撞","匀速","左转","右转"] print(rawLenth) print("正在生成新数据，请稍后...") while len(AugmentatedData)&lt;augNum: idx = np.random.randint(rawLenth,size = 2) # 注意：这里一定是copy() data = rawData[idx[0]].copy() data["Acc"] = weight*np.array(rawData[idx[0]]["Acc"])+(1-weight)*np.array(rawData[idx[1]]["Acc"]) data["Gyr"] = weight*rawData[idx[0]]["Gyr"]+(1-weight)*rawData[idx[1]]["Gyr"] if label == 1:#加速 主特征轴 ACC-X data["Acc"][0] = rawData[idx[0]]["Acc"][0] elif label == 2:#碰撞 主特征轴 ACC-X Gyr-Y data["Acc"][0] = rawData[idx[0]]["Acc"][0] data["Gyr"][1] = rawData[idx[0]]["Gyr"][1]# elif label == 3:#匀速 #主特征轴 无 elif label == 4:#左转 主特征轴 ACC-Y Gyr-Z data["Acc"][1] = rawData[idx[0]]["Acc"][1] data["Gyr"][2] = rawData[idx[0]]["Gyr"][2] elif label == 5:#右转 主特征轴 ACC-Y Gyr-Z data["Acc"][1] = rawData[idx[0]]["Acc"][1] data["Gyr"][2] = rawData[idx[0]]["Gyr"][2] #将生成的数据加入集合中 AugmentatedData.append(data) #print("已完成%d%%"%(int(len(AugmentatedData)*100/augNum))) print("数据增强已完成，目前数据个数%d"%(len(AugmentatedData))) AugmentatedData = np.array(AugmentatedData) # 将生成的新数据集保存 np.save(savePath+Labels[label-1],AugmentatedData) AandO = np.concatenate((rawData,AugmentatedData)) print(AandO.shape) # 将生成的数据集和原始数据集拼接后保存 np.save("../DataSet_NPSave/Aug1+orgin"+Labels[label-1],AandO) return AugmentatedData# 测试#DataArgument_1(accelerate_data,1,expNum=len(accelerate_data)+1)#DataArgument_1(collision_data,2)#DataArgument_1(uniform_speed_data,3)#DataArgument_1(left_turn_data,4)#DataArgument_1(right_turn_data,5) # 对各动作分别进行数据增强，并将增强后的数据拼接起来，AugDataAll为新生成的数据集（不包括原始数据）AugDataAll = np.concatenate((DataArgument_1(accelerate_data,1), DataArgument_1(collision_data,2), DataArgument_1(uniform_speed_data,3), DataArgument_1(left_turn_data,4), DataArgument_1(right_turn_data,5)))AugAndOrginData = np.concatenate((np.load("../DataSet_NPSave/Aug1+orgin加速.npy"), np.load("../DataSet_NPSave/Aug1+orgin碰撞.npy"), np.load("../DataSet_NPSave/Aug1+orgin匀速.npy"), np.load("../DataSet_NPSave/Aug1+orgin左转.npy"), np.load("../DataSet_NPSave/Aug1+orgin右转.npy"),))print(AugDataAll.shape)print(AugAndOrginData.shape)np.save("../DataSet_NPSave/AugDataAll",AugDataAll)np.save("../DataSet_NPSave/AugAndOrginData",AugAndOrginData)#%%'''算法二：背景噪声融合数据增强算法'''import GetDataUtilimport numpy as np'''背景噪声融合数据增强算法实现函数：rawData : 原始数据，字典noiseData ：噪声数据，数组 '''def DataArgument_2(rawData,noiseData,savePath="../DataSet_NPSave/NoiseAugmentatedData"): AugmentatedData = [] noiseLength = noiseData.shape[1] print("正在生成数据，请稍后...") for i in range(len(rawData)): newData = rawData[i].copy() # 随机切割 idx = np.random.randint(noiseLength-300,size = 1) newData["Acc"][:2] = newData["Acc"][:2]+noiseData[:2,idx[0]:idx[0]+300] newData["Acc"][2] = newData["Acc"][2]+noiseData[2,idx[0]:idx[0]+300]-1 # 减去噪声中的重力 newData["Gyr"] = newData["Gyr"]+noiseData[3:6,idx[0]:idx[0]+300] AugmentatedData.append(newData) print("已完毕，共生成%d个新数据。"%(len(AugmentatedData))) AugmentatedData = np.array(AugmentatedData) np.save(savePath,AugmentatedData) return AugmentatedData# 生成数据noiseDataDic = &#123;&#125;noiseData = np.concatenate(GetDataUtil.getAandG(GetDataUtil.readFile("../DataSet/静止/2017-12-23-匀速")),axis = 0)print(noiseData.shape)rawData = np.load("../DataSet_NPSave/AugAndOrginData.npy")AugmentatedData = DataArgument_2(rawData, noiseData, savePath="../DataSet_NPSave/NoiseAugmentatedData")print(AugmentatedData.shape)# 将通过噪声融合生成的数据和原始数据合并保存np.save("../DataSet_NPSave/NPAWF_Noise_orgin_all_5000", np.concatenate((rawData,AugmentatedData)))print("文件保存在：../DataSet_NPSave/NPAWF_Noise_orgin_all_5000.npy")#%%'''算法三：随即剪切数据增强rawData : 原始数据，字典'''def DataArgument_3(rawData,savePath="../DataSet_NPSave/RandomCropAugmentatedData"): AugmentatedData = [] print("正在生成数据，请稍后...") for data in rawData: newData = data.copy() idx = np.random.randint(150,size = 1) if data["Label"] == 2: # 该样本是“碰撞” while np.min(newData["Acc"][0]) != np.min(newData["Acc"][0,idx[0]:idx[0]+150]): idx = np.random.randint(150,size = 1) newData["Acc"] = newData["Acc"][:,idx[0]:idx[0]+150] newData["Gyr"] = newData["Gyr"][:,idx[0]:idx[0]+150] AugmentatedData.append(newData) print("已完毕，共生成%d个新数据。"%(len(AugmentatedData))) AugmentatedData = np.array(AugmentatedData) # 插值处理 return GetDataUtil.interpolation(AugmentatedData, sample = 300, kind ="cubic", savePath=savePath)rawData = np.load("../DataSet_NPSave/NPAWF_Noise_orgin_all_5000.npy")AugmentatedData = DataArgument_3(rawData, savePath="../DataSet_NPSave/RandomCropAugmentatedData")print(AugmentatedData.shape)# 将通过噪声融合生成的数据和原始数据合并保存np.save("../DataSet_NPSave/RandomCrop_NPAWF_Noise_orgin_all_10000", np.concatenate((rawData,AugmentatedData)))print("文件保存在：../DataSet_NPSave/RandomCrop_NPAWF_Noise_orgin_all_10000.npy")#%%'''提纯数据集,手动改变加速度'''orinDataSet = np.load("../DataSet_NPSave/RandomCrop_NPAWF_Noise_orgin_all_10000.npy")# Labels = ["加速","碰撞","匀速","左转","右转"]accelerate_data = []collision_data = []uniform_speed_data = []left_turn_data = []right_turn_data = []for data in orinDataSet: if data["Label"] == 1: accelerate_data.append(data) elif data["Label"] == 2: collision_data.append(data) elif data["Label"] == 3: uniform_speed_data.append(data) elif data["Label"] == 4: left_turn_data.append(data) elif data["Label"] == 5: right_turn_data.append(data)# 转换为numpyaccelerate_data = np.array(accelerate_data)collision_data = np.array(collision_data)uniform_speed_data = np.array(uniform_speed_data)left_turn_data = np.array(left_turn_data)right_turn_data = np.array(right_turn_data)print(accelerate_data.shape)print(collision_data.shape)print(uniform_speed_data.shape)print(left_turn_data.shape)print(right_turn_data.shape)count = 0for data in accelerate_data: data["Acc"][0] += 0.05 count += 1print("已完成%d个样本增加0.05"%(count)) # 数组拼接AllData_Acc_005 = np.concatenate((accelerate_data, collision_data, uniform_speed_data, left_turn_data, right_turn_data))np.save("../DataSet_NPSave/RandomCrop_NPAWF_Noise_orgin_all_ACC_005_10000.npy",AllData_Acc_005)count = 0for data in accelerate_data: data["Acc"][0] += 0.05 count += 1print("已完成%d个样本增加0.1"%(count))# 数组拼接AllData_Acc_01 = np.concatenate((accelerate_data, collision_data, uniform_speed_data, left_turn_data, right_turn_data))np.save("../DataSet_NPSave/RandomCrop_NPAWF_Noise_orgin_all_ACC_01_10000.npy",AllData_Acc_01)#%% #%%import matplotlib.pyplot as plt'''辅助函数： 生成单一样本数据波形图函数'''def showPic(data,picName,picSavePath = "Pic_temp"): Labels = ["加速","碰撞","匀速","左转","右转","静止噪声"] axisLabel = ["X","Y","Z"] colorLabel = ["r",'g',"b"] curLabel = -1 plt.rcParams['font.sans-serif']=['SIMHEI'] #用来正常显示中文标签 plt.rcParams['axes.unicode_minus']=False #用来正常显示负号 print("正在生成图片，请稍后......") curLabel = Labels[data["Label"]-1]#得到中文标签 print(curLabel) plt.figure(figsize=(13,10)) plt.suptitle(curLabel,fontsize=40,x=0.5,y=0.97) for i in range(3): plt.subplot(3,2,i*2+1) plt.title("加速度-"+axisLabel[i]) plt.plot(range(len(data["Acc"][i])),data["Acc"][i],color=colorLabel[i]) plt.subplot(3,2,i*2+2) plt.title("角速度-"+axisLabel[i]) plt.plot(range(len(data["Gyr"][i])),data["Gyr"][i],color=colorLabel[i]) plt.gcf().savefig(picSavePath+"/"+picName+".png",dpi = 120,bbox_inches='tight') print("生成图片完毕！") plt.close('all') #%% #测试：import GetDataUtilimport numpy as npnoiseDataDic = &#123;&#125;noiseData = np.concatenate(GetDataUtil.getAandG(GetDataUtil.readFile("DataSet/静止/2017-12-23-匀速")),axis = 0)print(noiseData.shape)noiseDataDic["Acc"] = noiseData[:3]noiseDataDic["Gyr"] = noiseData[3:6]noiseDataDic["Label"] = 6showPic(noiseDataDic,"noise",picSavePath = "Pic_temp") 你也可以点击查看你的GPU是否支持CUDA 满足以上条件之后，你就可以安装Tensorflow了！ 第一步：安装Anaconda1.下载和安装下载地址：https://www.anaconda.com/download/ 我系统是64位，所以下载 64-Bit Graphical Installer (631 MB)，之后就是进行安装了。 和安装其他软件没有什么区别，需要注意的是这一步，不要勾选**“Add Anaconda to my PATH enviroment variable”，我们后面会手动加入。 接下来就是等待了，安装结束后需要测试是否能正常使用，打开CMD输入“conda”命令，发现提示“’conda’ is not recognized as an internal or external command, operable program or batch file.” 这是由于我们没有配置环境变量的原因。 2.配置Anaconda环境变量我们点击左下角搜索栏搜索“环境变量” 点击环境变量 选择“Path”，点击“编辑” 将以下三个路径加入，注意这里要换成你自己的安装路径。 C:\Users\t-yaoguo\AppData\Local\Continuum\anaconda3 C:\Users\t-yaoguo\AppData\Local\Continuum\anaconda3\Scripts C:\Users\t-yaoguo\AppData\Local\Continuum\anaconda3\Library\bin 然后点击“确定”保存，这回再测试一下，再cmd中输入“conda -V”，能正常显示版本号，证明已经配置好了。 第二步：安装TensorFlow-GPU打开tensorflow官网：https://www.tensorflow.org/install/install_windows#installing_with_anaconda 跟着操作步骤走就可以了。 1.创建conda环境通过调用下列命令，创建一个名为“tensorflow”的conda环境： 1conda create -n tensorflow pip python=3.5 等待相应包的安装，如果国内网络太慢的话，可以为conda设置清华源，这样速度能快一点，具体配置过程，网上查一下吧，此处不再讲述。如果看到这样的提示，就证明conda环境创建成功。 2.激活环境通过以下命令激活conda环境： 1activate tensorflow 这样就进入了刚创建的“tensorflow”环境。 3.安装tensorflow-gpu安装GPU版本的tensorflow需要输入以下命令： 1pip install --ignore-installed --upgrade tensorflow-gpu 如果只需要安装CPU版本的tensorflow则输入以下命令： 1pip install --ignore-installed --upgrade tensorflow 这样就安装成功了。 注意：务必注意一点，在安装完tensroflow后，由于我们是新创建的conda环境，该环境中基本上是空的，有很多包和IDE并没有安装进来，例如“Ipython”，“spyder”此时如果我们在该环境下打开spyder/Ipyton/jupyter notebook等，会发现其实IDE使用的kernel并不是新建立的这个环境的kernel，而是“base”这个环境的，而“base”环境中我们并没有安装tensorflow，所以一定无法import。这也就是为什么有很多人在安装好tensorflow后仍然在IDE里无法正常使用的原因了。 通过以下命令安装Anaconda基础包 1conda install anaconda 这回，我们测试一下是否能import tensorflow 程序报错，这是由于我们虽然安装好了tensorflow-gpu，但是还需要安装CUDA Toolkit 和 cuDNN。 第三步：安装CUDA Toolkit + cuDNN1.查看需要安装的CUDA+cuDNN版本注意，tensorflow是在持续更新的，具体安装的CUDA和cuDNN版本需要去官网查看，要与最新版本的tensorflow匹配。 点击查看最新tensorflow支持的CUDA版本：https://www.tensorflow.org/install/install_windows#requirements_to_run_tensorflow_with_gpu_support 现在（PS：此博客书写日期 2018年7月5日）最新版tensorflow支持的是 CUDA® Toolkit 9.0 + cuDNN v7.0，一定注意，安装的版本一定一定要正确，不要看NVIDIA官网推出CUDA® Toolkit 9.2了就感觉最新版的更好，而安装最新版，这样很可能会导致tensorflow无法正常使用，所以一定要跟着tensorflow 官网的提示来。 2.下载CUDA + cuDNN在这个网址查找CUDA已发布版本：https://developer.nvidia.com/cuda-toolkit-archive 进入下载界面 下载好CUDA Toolkit 9.0 后，我们开始下载cuDnn 7.0，需要注意的是，下载cuDNN需要在nvidia上注册账号，使用邮箱注册就可以，免费的。登陆账号后才能下载。 cuDNN历史版本在该网址下载：https://developer.nvidia.com/rdp/cudnn-archive 这样，我们就下载好了 CUDA Toolkit 9.0 和 cuDnn 7.0，下面我们开始安装。 3.安装 CUDA Toolkit 9.0 和 cuDnn 7.0至关重要的一步：卸载显卡驱动由于CUDA Toolkit需要在指定版本显卡驱动环境下才能正常使用的，所以如果我们已经安装了nvidia显卡驱动（很显然，大部分人都安装了），再安装CUDA Toolkit时，会因二者版本不兼容而导致CUDA无法正常使用，这也就是很多人安装失败的原因。而CUDA Toolkit安装包中自带与之匹配的显卡驱动，所以务必要删除电脑先前的显卡驱动。 安装 此处选择“自定义（高级）” 勾选所有 一路通过即可。 接下来，解压“cudnn-9.0-windows10-x64-v7.zip”，将一下三个文件夹，拷贝到CUDA安装的根目录下。 这样CUDA Toolkit 9.0 和 cuDnn 7.0就已经安装了，下面要进行环境变量的配置。 配置环境变量将下面四个路径加入到环境变量中，注意要换成自己的安装路径。 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\bin C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\lib\x64 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\libnvvp 到此，全部的安装步骤都已经完成，这回我们测试一下。 第四步：测试1.查看是否使用GPU 12import tensorflow as tftf.test.gpu_device_name() 2.查看在使用哪个GPU 12from tensorflow.python.client import device_libdevice_lib.list_local_devices() 好了大功告成！ 希望这篇博文能给大家带来帮助，如有任何错误，欢迎指教交流。]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2019%2F05%2F06%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[标题一标题二]]></content>
      <categories>
        <category>deeplearning/test</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>first</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F06%2Fhello-world-1%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartWhen $a \ne 0$, there are two solutions to (ax^2 + bx + c = 0) and they are$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$ When $a \ne 0$, there are two solutions to (ax^2 + bx + c = 0) and they are$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$ When $a \ne 0$, there are two solutions to (ax^2 + bx + c = 0) and they are$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$ When $a \ne 0$, there are two solutions to (ax^2 + bx + c = 0) and they are$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$ Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
