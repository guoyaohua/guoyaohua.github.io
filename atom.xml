<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>郭耀华&#39;s Blog</title>
  
  <subtitle>欲穷千里目，更上一层楼。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.guoyaohua.com/"/>
  <updated>2019-07-21T10:37:47.482Z</updated>
  <id>http://www.guoyaohua.com/</id>
  
  <author>
    <name>郭耀华</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git常用操作指南</title>
    <link href="http://www.guoyaohua.com/Git-tutorial/"/>
    <id>http://www.guoyaohua.com/Git-tutorial/</id>
    <published>2019-07-21T15:17:08.000Z</published>
    <updated>2019-07-21T10:37:47.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为工作需求，最近又重新温习了一下Git操作，遂总结了一篇Git常用操作指南，方便日后学习查阅，本博客精简提炼了在开发过程中Git经常用到的核心命令，主要参考了《<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰老师的Git教程</a>》，希望对大家学习使用Git能带来帮助。</p><h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>Git是Linux之父Linus的第二个伟大的作品，它最早是在Linux上开发的，被用来管理Linux核心的源代码。后来慢慢地有人将其移植到了Unix、Windows、Max OS等操作系统中。</p><p>Git是一个分布式的版本控制系统，与集中式的版本控制系统不同的是，每个人都工作在通过克隆建立的本地版本库中。也就是说每个人都拥有一个完整的版本库，查看提交日志、提交、创建里程碑和分支、合并分支、回退等所有操作都直接在本地完成而不需要网络连接。</p><p>对于Git仓库来说，每个人都有一个独立完整的仓库，所谓的远程仓库或是服务器仓库其实也是一个仓库，只不过这台主机24小时运行，它是一个稳定的仓库，供他人克隆、推送，也从服务器仓库中拉取别人的提交。</p><p>Git是目前世界上最先进的分布式版本控制系统。</p><h2 id="安装之后第一步"><a href="#安装之后第一步" class="headerlink" title="安装之后第一步"></a>安装之后第一步</h2><p>安装完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure><p>因为Git是分布式版本控制系统，所以，每个机器都必须配置用户信息：你的名字和Email地址。</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><p>版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br><span class="line">Path</span><br><span class="line">----</span><br><span class="line">D:\Blog\tmp\learngit</span><br></pre></td></tr></table></figure><p>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> D:/Blog/tmp/learngit/.git/</span><br></pre></td></tr></table></figure><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="创建SSH-Key"><a href="#创建SSH-Key" class="headerlink" title="创建SSH Key"></a>创建SSH Key</h4><p>Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要在关联远程仓库前需要配置<code>SSH Key</code>至Github设置中，这样远程仓库才允许本机对远程仓库的拉去/推送操作。</p><p>打开<code>Shell</code>，进入到”<code>~/.ssh</code>“目录下，运行”<code>ls</code>“命令看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。</p><p>如果没有，则执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span><br></pre></td></tr></table></figure><p>一路回车即可。执行命令后，我们再进入到”<code>~/.ssh</code>“目录下，运行”<code>ls</code>“命令，可以看到里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p><img src="http://pic.guoyaohua.com/image/git/1563105584864.png" alt="1563105584864"></p><p>打开“Account settings”，“SSH Keys”页面，然后，点“New SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容（Win 10 下可使用”<code>type ~/.ssh/id_rsa.pub</code>“命令查看公钥文件内容）：</p><p><img src="http://pic.guoyaohua.com/image/git/1563105973152.png" alt="1563105973152"></p><p>点击“Add SSH Key”之后，就可以看到你的公钥已经加入到了你的Github仓库配置中。</p><p><img src="http://pic.guoyaohua.com/image/git/1563106045201.png" alt="1563106045201"></p><h4 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h4><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：</p><p><img src="http://pic.guoyaohua.com/image/git/1563103995786.png" alt="1563103995786"></p><p>在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p><p><img src="http://pic.guoyaohua.com/image/git/1563104100618.png" alt="1563104100618"></p><p>这样就成功创建了一个空白的远程仓库，那么如何将这个远程仓库与本地仓库进行关联呢？</p><p>我们根据Git所给出的提示可知，可以在本地创建一个新仓库对远程仓库进行关联，也可以对本地已有仓库进行关联。</p><h5 id="关联新仓库"><a href="#关联新仓库" class="headerlink" title="关联新仓库"></a>关联新仓库</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"# learngit"</span> &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line">git remote add origin git@github.com:guoyaohua/learngit.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h5 id="关联已有仓库"><a href="#关联已有仓库" class="headerlink" title="关联已有仓库"></a>关联已有仓库</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:guoyaohua/learngit.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>我们可以使用上文在本地初始化的“learngit”仓库。<strong>（注意：本地仓库和远程仓库可以不同名，本文只是为了写教程设置为相同名称。）</strong></p><p><img src="http://pic.guoyaohua.com/image/git/1563104810075.png" alt="1563104810075"></p><p>我们再刷新下<code>Github Code</code>界面，发现新加入的<code>README.md</code>文件已经推送到了远程仓库中。</p><p><img src="http://pic.guoyaohua.com/image/git/1563106284174.png" alt="1563106284174"></p><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><h4 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h4><p>就是你在电脑里能看到的目录，比如我们刚刚创建的<code>learngit</code>文件夹就是一个工作区：</p><p><img src="http://pic.guoyaohua.com/image/git/1563106681604.png" alt="1563106681604"></p><h4 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h4><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为<strong>Stage</strong>（或者叫<strong>Index</strong>）的<strong>暂存区</strong>，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p><img src="http://pic.guoyaohua.com/image/git/Repository.jpg" alt="Repository"></p><p>分支和<code>HEAD</code>的概念本文后面再详细说明。</p><p>我们把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到<strong>暂存区</strong>；</p><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><p>使用<code>git status</code>命令可以查看当前仓库的状态。</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>Git版本控制可以理解为，我们再编写代码的过程中，会对code进行多次修改，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p><p>在实际工作中，我们用<code>git log</code>命令查看我们提交的历史记录：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit <span class="number">1094</span>adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Yaohua Guo &lt;guo.yaohua@foxmail.com&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">21</span>:<span class="number">06</span>:<span class="number">15</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Yaohua Guo &lt;guo.yaohua@foxmail.com&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">21</span>:<span class="number">03</span>:<span class="number">36</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Yaohua Guo &lt;guo.yaohua@foxmail.com&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">18</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p>Git中，commit id是一个使用SHA1计算出来的一个非常大的数字，用十六进制表示，commit后面的那一串十六进制数字就是每一次提交的版本号，我们可以通过<code>git log</code>命令看到每次提交的版本号、用户名、日期以及版本描述等信息。</p><p>我们可以使用<code>git reset</code>命令进行版本回退操作。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>在Git中，用HEAD表示当前版本，上一个版本就是HEAD^ ，上上一个版本就是HEAD^^ ，以此类推，如果需要回退几十个版本，写几十个^容易数不过来，所以可以写，例如回退30个版本为：HEAD~30。</p><p>如果回退完版本又后悔了，想恢复，也是可以的，使用如下即可：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard commit_id</span><br></pre></td></tr></table></figure><p>不过当我们执行<code>git reset</code>进行版本回退之后，之前最新的版本号无法通过<code>git log</code>查询到，此时需要使用<code>git reflog</code>命令查询Git的操作记录，我们可以从该记录中找到之前的commit id信息。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;<span class="number">1</span>&#125;: reset: moving to HEAD^</span><br><span class="line"><span class="number">1094</span>adb (HEAD -&gt; master) HEAD@&#123;<span class="number">2</span>&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;<span class="number">3</span>&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;<span class="number">4</span>&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><p>在Git中，版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向回退的版本，然后顺便刷新工作区文件。</p><h4 id="重置命令"><a href="#重置命令" class="headerlink" title="重置命令"></a>重置命令</h4><p>重置命令的作用是将当前的分支重设（reset）到指定的<code>&lt;commit&gt;</code>或者<code>HEAD</code>（默认是HEAD，即最新的一次提交），并且根据[mode]有可能更新Index和Working directory（默认是mixed）。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset [--hard|soft|mixed|merge|keep] [commit|HEAD]</span><br></pre></td></tr></table></figure><ol><li>–hard：<strong>重设“暂存区”和“工作区”</strong>，从<code>&lt;commit&gt;</code>以来在工作区中的任何改变都被丢弃，并把HEAD指向<code>&lt;commit&gt;</code>。<strong>（彻底回退到某个版本，本地的源码也会变为上一个版本的内容。）</strong></li><li>–soft：<strong>“工作区”中的内容不作任何改变，HEAD指向<code>&lt;commit&gt;</code>，自从<code>&lt;commit&gt;</code>以来的所有改变都会回退到“暂存区”中，显示在<code>git status</code>的<em>“Changes to be committed”</em>中。（回退到某个版本，只回退了commit的信息。如果还要提交，直接commit即可。）</strong> </li><li>–mixed：<strong>仅重设“暂存区”，并把HEAD指向<code>&lt;commit&gt;</code>，但是不重设“工作区”，本地文件修改不受影响。</strong>这个模式是默认模式，即当不显示告知<code>git reset</code>模式时，会使用mixed模式。这个模式的效果是，工作区中文件的修改都会被保留，不会丢弃，但是也不会被标记成“<em>Changes to be committed</em>”，但是会提示文件未被更新。<strong>（回退到某个版本，只保留源码，回退commit和index信息）</strong> </li></ol><h5 id="文件粒度操作"><a href="#文件粒度操作" class="headerlink" title="文件粒度操作"></a>文件粒度操作</h5><p>需要注意的是在<code>mixed</code>模式下进行<code>reset</code>操作时可以是全局性重置，也可以是文件粒度重置，区别在于二者作用域不同，文件粒度只会使对应文件的暂存区状态变为指定commit时该文件的暂存区状态，并且不会改变版本库状态，即HEAD指针不会改变，我们看一下效果。</p><p>首先我们新建两个文件进行两次提交，可以看到目前HEAD指向最新一次提交“text2”。</p><p><img src="http://pic.guoyaohua.com/image/git/1563611168654.png" alt="1563611168654"></p><p>我们对“file1.txt”进行reset操作，令其重置为“text1”状态。</p><p><img src="http://pic.guoyaohua.com/image/git/1563611993505.png" alt="1563611993505"></p><p>并且我们通过git log命令可发现，此时HEAD指针并没有改变，还是指向最新一次提交“Text 2”，可知文件粒度的<code>reset --mixed</code>不改变版本库HEAD指针状态。</p><p><img src="http://pic.guoyaohua.com/image/git/1563612094551.png" alt="1563612094551"></p><p>对于soft和hard模式则无法进行文件粒度操作。</p><p><img src="http://pic.guoyaohua.com/image/git/1563609363728.png" alt="1563609363728"></p><h4 id="Reset-常用示例"><a href="#Reset-常用示例" class="headerlink" title="Reset 常用示例"></a>Reset 常用示例</h4><ul><li>回退add操作</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add test</span><br><span class="line">$ git reset HEAD test  </span><br><span class="line"><span class="comment"># HEAD指的是当前指向的版本号，可以将HEAD还成任意想回退的版本号</span></span><br></pre></td></tr></table></figure><p>可以将test从“已暂存”状态（Index区）回滚到指定Commit时暂存区的状态。</p><ul><li>回退最后一次提交</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add test</span><br><span class="line">$ git commit -m <span class="string">"Add test"</span></span><br><span class="line">$ git reset --soft HEAD^</span><br></pre></td></tr></table></figure><p>可以将test从“已提交”状态变为“已暂存”状态。 </p><ul><li>回退最近几次提交，并把这几次提交放到新分支上</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch topic <span class="comment"># 已当前分支为基础，新建分支topic</span></span><br><span class="line">$ git reset --hard HEAD~<span class="number">2</span> <span class="comment"># 在当前分支上回滚提交</span></span><br><span class="line">$ git checkout topic</span><br></pre></td></tr></table></figure><p>通过临时分支来保留提交，然后在当前分支上做硬回滚。 </p><ul><li>将本地的状态回退到和远程一样</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard origin/devlop</span><br></pre></td></tr></table></figure><ul><li>回退到某个版本提交</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset <span class="number">497</span>e350</span><br></pre></td></tr></table></figure><p>当前HEAD会指向“497e350”，暂存区中的状态会恢复到提交“497e350”时暂存区的状态。 </p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>当我们因为一些原因想要丢弃工作区某些文件修改时，可以使用“<code>git checkout -- &lt;file&gt;</code>”命令，该命令仅会恢复工作区文件状态，不会对版本库有任何改动。</p><p><img src="http://pic.guoyaohua.com/image/git/1563613938574.png" alt="1563613938574"></p><p>命令<code>git checkout -- file1.txt</code>意思就是，把<code>file1.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><ul><li>一种是<code>file1.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种是<code>file1.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li></ul><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交：</p><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm test.txt</span><br></pre></td></tr></table></figure><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add/rm &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">deleted:    test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm <span class="string">'test.txt'</span></span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"remove test.txt"</span></span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> deletion(-)</span><br><span class="line"> delete mode <span class="number">100644</span> test.txt</span><br></pre></td></tr></table></figure><p>现在，文件就从版本库中被删除了。</p><blockquote><p>提示：先手动删除文件，然后使用<code>git rm &lt;file&gt;</code>和<code>git add &lt;file&gt;</code>效果是一样的。</p></blockquote><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><blockquote><p>注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</p></blockquote><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>在上文“版本回退”里，我们已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p><p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p><p><img src="http://pic.guoyaohua.com/image/git/0.png" alt></p><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p><p><img src="http://pic.guoyaohua.com/image/git/1.png" alt></p><p>Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化。</p><p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><p><img src="http://pic.guoyaohua.com/image/git/2.png" alt></p><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><p><img src="http://pic.guoyaohua.com/image/git/3.png" alt></p><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p><p><img src="http://pic.guoyaohua.com/image/git/4.png" alt></p><p>下面开始实战。</p><p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev <span class="comment"># 创建dev分支</span></span><br><span class="line">$ git checkout dev <span class="comment"># 切换到dev分支</span></span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure><p>然后，用<code>git branch</code>命令查看当前分支：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p><p>然后，我们就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改，加上一行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick.</span><br></pre></td></tr></table></figure><p>然后提交：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"branch test"</span></span><br><span class="line">[dev b17d20e] branch test</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure><p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure><p>切换回<code>master</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：</p><p><img src="http://pic.guoyaohua.com/image/git/5.png" alt></p><p>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d46f35e..b17d20e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | <span class="number">1</span> +</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure><p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code>readme.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p><p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p><p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p><p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure><p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>在真正开发过程中，合并分支经常会遇到分支冲突的情况，无法直接合并，我们来模拟一下这个场景。</p><p>准备新的<code>feature1</code>分支，继续我们的新分支开发：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature1</span><br><span class="line">Switched to a new branch <span class="string">'feature1'</span></span><br></pre></td></tr></table></figure><p>修改<code>readme.txt</code>最后一行，改为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick AND simple.</span><br></pre></td></tr></table></figure><p>在<code>feature1</code>分支上提交：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"AND simple"</span></span><br><span class="line">[feature1 <span class="number">14096</span>d0] AND simple</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure><p>切换到<code>master</code>分支：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by <span class="number">1</span> commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your local commits)</span><br></pre></td></tr></table></figure><p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p><p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick &amp; simple.</span><br></pre></td></tr></table></figure><p>提交：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"&amp; simple"</span></span><br><span class="line">[master <span class="number">5</span>dc6824] &amp; simple</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure><p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p><p><img src="http://pic.guoyaohua.com/image/git/6.png" alt></p><p>这种情况下，Git无法执行“快速合并(Fast-forward)”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by <span class="number">2</span> commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your local commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">"git commit"</span>)</span><br><span class="line">  (use <span class="string">"git merge --abort"</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">both modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>我们可以直接查看readme.txt的内容：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure><p>再提交：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"conflict fixed"</span></span><br><span class="line">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure><p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p><p><img src="http://pic.guoyaohua.com/image/git/7.png" alt></p><p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * <span class="number">14096</span>d0 (feature1) AND simple</span><br><span class="line">* | <span class="number">5</span>dc6824 &amp; simple</span><br><span class="line">|/  </span><br><span class="line">* b17d20e branch test</span><br><span class="line">* d46f35e (origin/master) remove test.txt</span><br><span class="line">* b84166e add test.txt</span><br><span class="line">* <span class="number">519219</span>b git tracks changes</span><br><span class="line">* e43a48b understand how stage works</span><br><span class="line">* <span class="number">1094</span>adb append GPL</span><br><span class="line">* e475afc add distributed</span><br><span class="line">* eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure><p>最后，删除<code>feature1</code>分支：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature1</span><br><span class="line">Deleted branch feature1 (was <span class="number">14096</span>d0).</span><br></pre></td></tr></table></figure><p>工作完成。</p><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p><p>首先，仍然创建并切换<code>dev</code>分支：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure><p>修改readme.txt文件，并提交一个新的commit：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"add merge"</span></span><br><span class="line">[dev f52c633] add merge</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure><p>现在，我们切换回<code>master</code>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure><p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">"merge with no-ff"</span> dev</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> readme.txt | <span class="number">1</span> +</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><p>合并后，我们用<code>git log</code>看看分支历史：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p><p><img src="http://pic.guoyaohua.com/image/git/8.png" alt></p><h4 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h4><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和团队同事每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="http://pic.guoyaohua.com/image/git/9.png" alt></p><h3 id="状态存储"><a href="#状态存储" class="headerlink" title="状态存储"></a>状态存储</h3><p>当我们在开发过程中，经常遇到这样的情况，我们需要暂时放下手中的工作，切换到其他分支进行开发，例如当我们在dev分支进行程序2.0版本开发时，发现1.0版本的程序出现了bug，必须立刻进行修复，但是在目前的dev分支我们可能已经做了很多修改，暂存区可能有了暂存状态，甚至可能在开发过程中在dev分支进行了多次commit，这时如果我们想切换回master分支，进行bug修复，这时就需要使用到<code>git stash</code>命令存储原分支当前的状态。</p><p>在讲解<code>git stash</code>之前，我们先考虑两种场景：</p><p>第一种就是我们未在dev分支进行任何提交，此时HEAD指针指向dev，dev和master指向同一次commit，如下图：</p><p><img src="http://pic.guoyaohua.com/image/git/1563631355797.png" alt="1563631355797"></p><p>我们可能在dev的工作区做了很多修改，也将部分修改状态加入了暂存区（即进行了<code>git add</code>操作），这时我们尝试一下直接使用<code>git checkout</code>命令切换分支。</p><p>此时，Git状态如下：</p><p><img src="http://pic.guoyaohua.com/image/git/1563631585919.png" alt="1563631585919"></p><p>我们修改“file1.txt”和“file2.txt”的内容，并将“file1.txt”的改动加入暂存区。</p><p><img src="http://pic.guoyaohua.com/image/git/1563631787056.png" alt="1563631787056"></p><p>此时可看出工作区和暂存区就都有改变，但HEAD指针指向的dev与master为同一个commit节点。</p><p>这时我们执行<code>git checkout master</code>命令尝试切换分支。</p><p><img src="http://pic.guoyaohua.com/image/git/1563631937563.png" alt="1563631937563"></p><p>可以看出，成功切换到了master分支上，而且工作区和暂存区的状态依旧保留。</p><p>我们再考虑一个场景，在dev分支开发时，进行了一次提交，此时HEAD指向dev分支，dev分支超前master分支一次commit，具体见下图：</p><p><img src="http://pic.guoyaohua.com/image/git/1563632158366.png" alt="1563632158366"></p><p>如果此时我们工作区或暂存区有未提交更改时，就无法进行分支切换操作（如果没有未提交修改的话当然可以进行分支切换操作）。 </p><p><img src="http://pic.guoyaohua.com/image/git/1563632645976.png" alt="1563632645976"></p><p>我想这时大家就会有一个疑问，为什么两种状态下我们都修改了暂存区和工作区的状态，但是一个可以切换分支并且保留工作区、暂存区状态，而另一种状态就无法切换分支呢？</p><p>我起初在遇到这个问题的时候也是很诧异，在网上搜索了好多资料，依旧没有查到有价值的信息。</p><p>这时我们就应该从Git的原理来进行分析了，<strong>Git在进行版本控制时，记录的并不是文件本身的信息，而是文件的修改状态</strong>，例如我们再一个10000行代码的文件中，新加入了一行代码进行，Git并不是将最新的10001行代码作为备份，而是仅仅记录了新旧文件之间的差异，即在哪个位置修改了什么内容（修改包括：增加、删除、修改等）。</p><p>我们来分析一下上问题到的第一种场景：我们未在dev分支进行任何提交，此时HEAD指针指向dev，dev和master指向同一次commit。</p><p>虽然我们再dev分支的工作区和暂存区做了修改，这些修改都是基于dev指向的commit而言的，而且此时dev和master指向同一个commit，所以，该场景下，dev分支工作区和暂存区的修改依旧适用于master分支，所以可以成功切换分支。</p><p>而第二种场景：在dev分支开发时，进行了一次提交，此时HEAD指向dev分支，dev分支超前master分支一次commit。</p><p>这时，dev工作区和暂存区的状态是基于最新的dev指向的commit而言的，已经不能应用于master指向的commit了，所以在进行切换分支时，提示报错。</p><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，当前正在<code>dev</code>上进行的工作还没有提交：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p><p>幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p><p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by <span class="number">6</span> commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your local commits)</span><br><span class="line"></span><br><span class="line">$ git checkout -b issue-<span class="number">101</span></span><br><span class="line">Switched to a new branch <span class="string">'issue-101'</span></span><br></pre></td></tr></table></figure><p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"fix bug 101"</span></span><br><span class="line">[issue-<span class="number">101</span> <span class="number">4</span>c805e2] fix bug <span class="number">101</span></span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure><p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by <span class="number">6</span> commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your local commits)</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m <span class="string">"merged bug fix 101"</span> issue-<span class="number">101</span></span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> readme.txt | <span class="number">2</span> +-</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure><p>修复好BUG之后，就可以返回原分支继续之前的工作了。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;<span class="number">0</span>&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Dropped refs/stash@&#123;<span class="number">0</span>&#125; (<span class="number">5</span>d677e2ee266f39ea296182fb2354265b91b3b2a)</span><br></pre></td></tr></table></figure><p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p><p>用<code>git remote -v</code>查看远程库的详细信息：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:guoyaohua/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:guoyaohua/learngit.git (push)</span><br></pre></td></tr></table></figure><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p><h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p><p>现在，模拟一个你的同事，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:guoyaohua/learngit.git</span><br><span class="line">Cloning into <span class="string">'learngit'</span>...</span><br><span class="line">remote: Counting objects: <span class="number">40</span>, done.</span><br><span class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">21</span>/<span class="number">21</span>), done.</span><br><span class="line">remote: Total <span class="number">40</span> (delta <span class="number">14</span>), reused <span class="number">40</span> (delta <span class="number">14</span>), pack-reused <span class="number">0</span></span><br><span class="line">Receiving objects: <span class="number">100</span>% (<span class="number">40</span>/<span class="number">40</span>), done.</span><br><span class="line">Resolving deltas: <span class="number">100</span>% (<span class="number">14</span>/<span class="number">14</span>), done.</span><br></pre></td></tr></table></figure><p>当你的同事从远程库clone时，默认情况下，你的同事只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>现在，你的同事要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"add env"</span></span><br><span class="line">[dev <span class="number">7</span>a5e5dd] add env</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br><span class="line"> create mode <span class="number">100644</span> env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: <span class="number">3</span>, done.</span><br><span class="line">Delta compression using up to <span class="number">4</span> threads.</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">308</span> bytes | <span class="number">308.00</span> KiB/s, done.</span><br><span class="line">Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f52c633..<span class="number">7</span>a5e5dd  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>你的同事已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ type env.txt</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"add new env"</span></span><br><span class="line">[dev <span class="number">7</span>bd91f1] add new env</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br><span class="line"> create mode <span class="number">100644</span> env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">'git@github.com:guoyaohua/learngit.git'</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>推送失败，因为你的同事的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(<span class="number">1</span>) <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> you wish to set tracking information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure><p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch <span class="string">'dev'</span> set up to track remote branch <span class="string">'dev'</span> from <span class="string">'origin'</span>.</span><br></pre></td></tr></table></figure><p>再pull：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict <span class="keyword">in</span> env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"fix env conflict"</span></span><br><span class="line">[dev <span class="number">57</span>c53ab] fix env conflict</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: <span class="number">6</span>, done.</span><br><span class="line">Delta compression using up to <span class="number">4</span> threads.</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">4</span>/<span class="number">4</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">6</span>/<span class="number">6</span>), <span class="number">621</span> bytes | <span class="number">621.00</span> KiB/s, done.</span><br><span class="line">Total <span class="number">6</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">To git@github.com:guoyaohua/learngit.git</span><br><span class="line">   <span class="number">7</span>a5e5dd..<span class="number">57</span>c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>因此，多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p><code>git rebase</code>和<code>git merge</code>做的事其实是一样的。它们都被设计来将一个分支的更改并入另一个分支，只不过方式有些不同。</p><p><code>git rebase</code>用于把一个分支的修改合并到当前分支。</p><p>假设你现在基于远程分支”origin”，创建一个叫”mywork”的分支。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b mywork origin</span><br></pre></td></tr></table></figure><p>假设远程分支”origin”已经有了2个提交，如图：</p><p><img src="http://pic.guoyaohua.com/image/git/rebase0.png" alt></p><p>现在我们在这个分支做一些修改，然后生成两个提交(commit)。</p><p>但是与此同时，有些人也在”origin”分支上做了一些修改并且做了提交了. 这就意味着”origin”和”mywork”这两个分支各自”前进”了，它们之间”分叉”了。</p><p><img src="http://pic.guoyaohua.com/image/git/rebase1.png" alt></p><p>在这里，你可以用“pull”命令把“origin”分支上的修改拉下来并且和你的修改合并； 结果看起来就像一个新的”合并的提交”(merge commit):</p><p><img src="http://pic.guoyaohua.com/image/git/rebase2.png" alt></p><p>但是，如果你想让“mywork”分支历史看起来像没有经过任何合并一样，你也许可以用 <code>git rebase</code>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout mywork</span><br><span class="line">$ git rebase origin</span><br></pre></td></tr></table></figure><p>这些命令会把你的”mywork”分支里的每个提交(commit)取消掉，并且把它们临时保存为补丁(patch)(这些补丁放到”.git/rebase”目录中)，然后把”mywork”分支更新为最新的”origin”分支，最后把保存的这些补丁应用到”mywork”分支上。</p><p><img src="http://pic.guoyaohua.com/image/git/rebase3.png" alt></p><p>当”mywork”分支更新之后，它会指向这些新创建的提交(commit)，而那些老的提交会被丢弃。 如果运行垃圾收集命令(pruning garbage collection)，这些被丢弃的提交就会删除。</p><p><img src="http://pic.guoyaohua.com/image/git/rebase4.png" alt></p><p>现在我们可以看一下用merge和用rebase所产生的历史的区别：</p><p><img src="http://pic.guoyaohua.com/image/git/1563677573806.png" alt="1563677573806"></p><p><img src="http://pic.guoyaohua.com/image/git/rebase2.png" alt></p><p>当我们使用<code>git log</code>来参看commit时，其commit的顺序也有所不同。</p><p>假设C3提交于<code>9:00AM</code>，C5提交于<code>10:00AM</code>，C4提交于<code>11:00AM</code>，C6提交于<code>12:00AM</code>，</p><p>对于使用<code>git merge</code>来合并所看到的commit的顺序（从新到旧）是：</p><p>C7，C6，C4，C5，C3，C2，C1</p><p>对于使用git rebase来合并所看到的commit的顺序（从新到旧）是：</p><p>C7，C6’，C5’，C4，C3，C2，C1</p><p> 因为C6’提交只是C6提交的克隆，C5’提交只是C5提交的克隆，</p><p>从用户的角度看使用<code>git rebase</code>来合并后所看到的commit的顺序（从新到旧）是：</p><p>C7，C6，C5，C4，C3，C2，C1</p><p>另外，我们在使用<code>git pull</code>命令的时候，可以使用<code>--rebase</code>参数，即<code>git pull --rebase</code>，这里Git会把你的本地当前分支里的每个提交(commit)取消掉，并且把它们临时保存为补丁(patch)(这些补丁放到”.git/rebase”目录中),然后把分支更新 为最新的”origin”分支，最后把保存的这些补丁应用到分支上。</p><h4 id="解决冲突-1"><a href="#解决冲突-1" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>在rebase的过程中，也许会出现冲突(conflict)。在这种情况，Git会停止rebase并会让你去解决冲突。rebase和merge的另一个区别是rebase的冲突是一个一个解决，如果有十个冲突，在解决完第一个冲突后，用”<code>git add</code>“命令去更新这些内容的索引(index)，然后，你无需执行 git-commit，只要执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add -u </span><br><span class="line">$ git rebase --continue</span><br></pre></td></tr></table></figure><p>继续后才会出现第二个冲突，直到所有冲突解决完，而merge是所有的冲突都会显示出来。 </p><p>在任何时候，你可以用<code>--abort</code>参数来终止rebase的行动，并且”mywork” 分支会回到rebase开始前的状态。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --abort</span><br></pre></td></tr></table></figure><p>所以rebase的工作流就是</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git rebase </span><br><span class="line"><span class="keyword">while</span>(存在冲突) &#123;</span><br><span class="line">    git status</span><br><span class="line">    <span class="comment"># 找到当前冲突文件，编辑解决冲突</span></span><br><span class="line">    git add -u</span><br><span class="line">    git rebase --continue</span><br><span class="line">    <span class="keyword">if</span>( git rebase --abort )</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后冲突全部解决，rebase成功。</p><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像，但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><p>Git有commit，为什么还要引入tag？</p><p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p><p>“一串乱七八糟的数字不好找！”</p><p>如果换一个办法：</p><p>“请把上周一的那个版本打包发布，版本号是v1.2”</p><p>“好的，按照tag v1.2查找commit就行！”</p><p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure><p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以用命令<code>git tag</code>查看所有标签：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline --abbrev-commit</span><br><span class="line"><span class="number">12</span>a631b (HEAD -&gt; master, tag: v1.<span class="number">0</span>, origin/master) merged bug fix <span class="number">101</span></span><br><span class="line"><span class="number">4</span>c805e2 fix bug <span class="number">101</span></span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line">f52c633 add merge</span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line"><span class="number">5</span>dc6824 &amp; simple</span><br><span class="line"><span class="number">14096</span>d0 AND simple</span><br><span class="line">b17d20e branch test</span><br><span class="line">d46f35e remove test.txt</span><br><span class="line">b84166e add test.txt</span><br><span class="line"><span class="number">519219</span>b git tracks changes</span><br><span class="line">e43a48b understand how stage works</span><br><span class="line"><span class="number">1094</span>adb append GPL</span><br><span class="line">e475afc add distributed</span><br><span class="line">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure><p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code>，敲入命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.<span class="number">9</span> f52c633</span><br></pre></td></tr></table></figure><p>再用命令<code>git tag</code>查看标签：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.<span class="number">9</span></span><br><span class="line">v1.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.<span class="number">9</span></span><br><span class="line">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.<span class="number">9</span>)</span><br><span class="line">Author: Yaohua Guo &lt;guo.yaohua@foxmail.com&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">54</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.<span class="number">1</span> -m <span class="string">"version 0.1 released"</span> <span class="number">1094</span>adb</span><br></pre></td></tr></table></figure><p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.<span class="number">1</span></span><br><span class="line">tag v0.<span class="number">1</span></span><br><span class="line">Tagger: Yaohua Guo &lt;guo.yaohua@foxmail.com&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">22</span>:<span class="number">48</span>:<span class="number">43</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">version <span class="number">0.1</span> released</span><br><span class="line"></span><br><span class="line">commit <span class="number">1094</span>adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.<span class="number">1</span>)</span><br><span class="line">Author: Yaohua Guo &lt;guo.yaohua@foxmail.com&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">21</span>:<span class="number">06</span>:<span class="number">15</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>如果标签打错了，也可以删除：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.<span class="number">1</span></span><br><span class="line">Deleted tag <span class="string">'v0.1'</span> (was f15b0dd)</span><br></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.<span class="number">0</span></span><br><span class="line">Total <span class="number">0</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">To git@github.com:guoyaohua/learngit.git</span><br><span class="line"> * [new tag]         v1.<span class="number">0</span> -&gt; v1.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Total <span class="number">0</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">To git@github.com:guoyaohua/learngit.git</span><br><span class="line"> * [new tag]         v0.<span class="number">9</span> -&gt; v0.<span class="number">9</span></span><br></pre></td></tr></table></figure><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.<span class="number">9</span></span><br><span class="line">Deleted tag <span class="string">'v0.9'</span> (was f52c633)</span><br></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.<span class="number">9</span></span><br><span class="line">To git@github.com:guoyaohua/learngit.git</span><br><span class="line"> - [deleted]         v0.<span class="number">9</span></span><br></pre></td></tr></table></figure><p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p><h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><h3 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h3><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次<code>git status</code>都会显示<code>Untracked files ...</code>，有强迫症的朋友心里肯定不爽。</p><p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p><p>不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p><p>忽略文件的原则是：</p><ol><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ol><p>举个例子：</p><p>假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有<code>Desktop.ini</code>文件，因此你需要忽略Windows自动生成的垃圾文件：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Windows:</span></span><br><span class="line">Thumbs<span class="meta">.db</span></span><br><span class="line">ehthumbs<span class="meta">.db</span></span><br><span class="line">Desktop.ini</span><br></pre></td></tr></table></figure><p>然后，继续忽略Python编译产生的<code>.pyc</code>、<code>.pyo</code>、<code>dist</code>等文件或目录：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">Python</span>:</span><br><span class="line">*<span class="selector-class">.py</span><span class="selector-attr">[cod]</span></span><br><span class="line">*<span class="selector-class">.so</span></span><br><span class="line">*<span class="selector-class">.egg</span></span><br><span class="line">*<span class="selector-class">.egg-info</span></span><br><span class="line"><span class="selector-tag">dist</span></span><br><span class="line"><span class="selector-tag">build</span></span><br></pre></td></tr></table></figure><p>加上你自己定义的文件，最终得到一个完整的<code>.gitignore</code>文件，内容如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">Windows</span>:</span><br><span class="line"><span class="selector-tag">Thumbs</span><span class="selector-class">.db</span></span><br><span class="line"><span class="selector-tag">ehthumbs</span><span class="selector-class">.db</span></span><br><span class="line"><span class="selector-tag">Desktop</span><span class="selector-class">.ini</span></span><br><span class="line"></span><br><span class="line"># <span class="selector-tag">Python</span>:</span><br><span class="line">*<span class="selector-class">.py</span><span class="selector-attr">[cod]</span></span><br><span class="line">*<span class="selector-class">.so</span></span><br><span class="line">*<span class="selector-class">.egg</span></span><br><span class="line">*<span class="selector-class">.egg-info</span></span><br><span class="line"><span class="selector-tag">dist</span></span><br><span class="line"><span class="selector-tag">build</span></span><br><span class="line"></span><br><span class="line"># <span class="selector-tag">My</span> <span class="selector-tag">configurations</span>:</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.ini</span></span><br><span class="line"><span class="selector-tag">deploy_key_rsa</span></span><br></pre></td></tr></table></figure><p>最后一步就是把<code>.gitignore</code>也提交到Git，就完成了！当然检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说<code>working directory clean</code>。</p><p>使用Windows的朋友注意了，如果你在资源管理器里新建一个<code>.gitignore</code>文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为<code>.gitignore</code>了。</p><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add App.class</span><br><span class="line">The following paths are ignored by one of your .gitignore files:</span><br><span class="line">App.class</span><br><span class="line">Use -f <span class="keyword">if</span> you really want to add them.</span><br></pre></td></tr></table></figure><p>如果你确实想添加该文件，可以用<code>-f</code>强制添加到Git：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -f App.class</span><br></pre></td></tr></table></figure><p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git check-ignore -v App.class</span><br><span class="line">.gitignore:<span class="number">3</span>:*.classApp.class</span><br></pre></td></tr></table></figure><p>Git会告诉我们，<code>.gitignore</code>的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>有没有经常敲错命令？比如<code>git status</code>？<code>status</code>这个单词真心不好记。</p><p>如果敲<code>git st</code>就表示<code>git status</code>那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p><p>我们只需要敲一行命令，告诉Git，以后<code>st</code>就表示<code>status</code>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure><p>好了，现在敲<code>git st</code>看看效果。</p><p>当然还有别的命令可以简写，很多人都用<code>co</code>表示<code>checkout</code>，<code>ci</code>表示<code>commit</code>，<code>br</code>表示<code>branch</code>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.br branch</span><br></pre></td></tr></table></figure><p>以后提交就可以简写成：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git ci -m <span class="string">"bala bala bala..."</span></span><br></pre></td></tr></table></figure><p><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p><p>在撤销修改一节中，我们知道，命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个<code>unstage</code>别名：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.unstage <span class="string">'reset HEAD'</span></span><br></pre></td></tr></table></figure><p>当你敲入命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git unstage test.py</span><br></pre></td></tr></table></figure><p>实际上Git执行的是：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD test.py</span><br></pre></td></tr></table></figure><p>配置一个<code>git last</code>，让其显示最后一次提交信息：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.last <span class="string">'log -1'</span></span><br></pre></td></tr></table></figure><p>这样，用<code>git last</code>就能显示最近一次的提交：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git last</span><br><span class="line">commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2</span><br><span class="line">Merge: bd6ae48 <span class="number">291</span>bea8</span><br><span class="line">Author: Yaohua Guo &lt;Guo.Yaohua@foxmail.com&gt;</span><br><span class="line">Date:   Thu Aug <span class="number">22</span> <span class="number">22</span>:<span class="number">49</span>:<span class="number">22</span> <span class="number">2013</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    merge &amp; fix hello.py</span><br></pre></td></tr></table></figure><p>甚至可以进一步美化把<code>lg</code>配置成：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></span><br></pre></td></tr></table></figure><p>来看看<code>git lg</code>的效果：</p><p><img src="http://pic.guoyaohua.com/image/git/10.png" alt></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p><p>配置文件放哪了？每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ type .git/config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = <span class="number">0</span></span><br><span class="line">    filemode = true</span><br><span class="line">    bare = false</span><br><span class="line">    logallrefupdates = true</span><br><span class="line">    ignorecase = true</span><br><span class="line">    precomposeunicode = true</span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">    url = git@github.com:michaelliao/learngit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[alias]</span><br><span class="line">    last = log -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p><p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ type .gitconfig</span><br><span class="line">[alias]</span><br><span class="line">    co = checkout</span><br><span class="line">    ci = commit</span><br><span class="line">    br = branch</span><br><span class="line">    st = status</span><br><span class="line">[user]</span><br><span class="line">    name = Your Name</span><br><span class="line">    email = your@email.com</span><br></pre></td></tr></table></figure><p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Git记录的是文件的修改状态，而不是文件本身。</li><li>初始化一个Git仓库，使用<code>git init</code>命令。</li><li>添加文件到Git仓库，分两步：<ul><li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li></ul></li><li>每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</li><li>提交后，可用<code>git diff HEAD -- &lt;file_name&gt;</code>命令可以查看工作区和版本库里面最新版本的区别。</li><li>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容，此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改。</li><li>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。</li><li>HEAD<code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令</code>git reset –hard commit_id`。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li><li>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li><li>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，第二步按上一条操作。</li><li>已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退，不过前提是没有推送到远程库。</li><li>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</li><li>Git鼓励大量使用分支：<ul><li>查看分支：<code>git branch</code></li><li>创建分支：<code>git branch &lt;name&gt;</code></li><li>切换分支：<code>git checkout &lt;name&gt;</code></li><li>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></li><li>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></li><li>删除分支：<code>git branch -d &lt;name&gt;</code></li></ul></li><li>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</li><li>用<code>git log --graph</code>命令可以看到分支合并图。</li><li>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</li><li>切换分支使用<code>git checkout &lt;master&gt;</code> ，HEAD指向master，工作区也恢复到master的状态。 </li><li>开发一个新feature，最好新建一个分支。</li><li>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</li><li>查看远程库信息，使用<code>git remote -v</code>。</li><li>本地新建的分支如果不推送到远程，对其他人就是不可见的。</li><li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交。</li><li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致。</li><li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>。</li><li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li><li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id。</li><li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息。</li><li>命令<code>git tag</code>可以查看所有标签。</li><li>忽略某些文件时，需要编写<code>.gitignore</code>。</li><li><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;因为工作需求，最近又重新温习了一下Git操作，遂总结了一篇Git常用操作指南，方便日后学习查阅，本博客精简提炼了在开发过程中Git经常用到的
      
    
    </summary>
    
      <category term="Git" scheme="http://www.guoyaohua.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.guoyaohua.com/tags/Git/"/>
    
      <category term="Git教程" scheme="http://www.guoyaohua.com/tags/Git%E6%95%99%E7%A8%8B/"/>
    
      <category term="Git常用命令" scheme="http://www.guoyaohua.com/tags/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Git常用操作" scheme="http://www.guoyaohua.com/tags/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>深度学习工作站攒机指南</title>
    <link href="http://www.guoyaohua.com/deeplearning-workstation/"/>
    <id>http://www.guoyaohua.com/deeplearning-workstation/</id>
    <published>2019-05-09T03:59:47.399Z</published>
    <updated>2019-06-23T08:39:15.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>接触深度学习已经快两年了，之前一直使用<a href="https://colab.research.google.com" target="_blank" rel="noopener">Google Colab</a>和<a href="https://www.kaggle.com/kernels" target="_blank" rel="noopener">Kaggle Kernel</a>提供的免费GPU（Tesla K80）训练模型（最近Google将Colab的GPU升级为<strong>Tesla T4</strong>，计算速度又提升了一个档次），不过由于内地网络的原因，Google和Kaggle连接十分不稳定，经常断线重连，一直是很令人头痛的问题，而且二者均有很多限制，例如Google Colab一个脚本运行的最长时间为12h，Kaggle的为6h，数据集上传也存在问题，需要使用一些Trick才能达成目的，模型的保存、下载等都会耗费很多精力，总之体验不是很好，不过免费的羊毛让大家撸，肯定会有一些限制，也是可以理解的。</p><p>对于租用云服务器，之前也尝试过，租用了一家小平台的GPU服务器，也存在一些操作上的困难，不适合程序调试，而且价格也不便宜。</p><p>很早之前就想要搭建一个自己的深度学习工作站，不过机器成本的昂贵，一直阻碍着我攒机计划的进行。工欲善其事，必先利其器！最近终于下定决心，置办一个深度学习工作站主机。本文将我在这段时间选择、购置硬件的心得体会，分享给大家。</p><h2 id="配置清单"><a href="#配置清单" class="headerlink" title="配置清单"></a>配置清单</h2><table><thead><tr><th style="text-align:center">配件</th><th style="text-align:center">品牌型号</th><th style="text-align:center">数量</th><th style="text-align:center">价格</th><th style="text-align:center">渠道</th></tr></thead><tbody><tr><td style="text-align:center">CPU</td><td style="text-align:center">Intel 酷睿i7 6950X 至尊版</td><td style="text-align:center">1</td><td style="text-align:center">3300</td><td style="text-align:center">散片</td></tr><tr><td style="text-align:center">主板</td><td style="text-align:center">华硕 RAMPAGE V EXTREME X99 主板</td><td style="text-align:center">1</td><td style="text-align:center">1085</td><td style="text-align:center">二手</td></tr><tr><td style="text-align:center">内存</td><td style="text-align:center">海盗船 复仇者LPX 16GB DDR4 2400</td><td style="text-align:center">4</td><td style="text-align:center">1920</td><td style="text-align:center">全新</td></tr><tr><td style="text-align:center">HDD</td><td style="text-align:center">西部数据 WD40EZRZ 蓝盘 4TB</td><td style="text-align:center">1</td><td style="text-align:center">550</td><td style="text-align:center">OEM</td></tr><tr><td style="text-align:center">SSD</td><td style="text-align:center">西数 WDS100T2X0C 黑盘 1TB</td><td style="text-align:center">1</td><td style="text-align:center">1220</td><td style="text-align:center">全新</td></tr><tr><td style="text-align:center">显卡</td><td style="text-align:center">影驰 GeForce RTX 2070 大将</td><td style="text-align:center">1</td><td style="text-align:center">3400</td><td style="text-align:center">全新</td></tr><tr><td style="text-align:center">机箱</td><td style="text-align:center">爱国者（aigo）月光宝盒 破晓</td><td style="text-align:center">1</td><td style="text-align:center">264</td><td style="text-align:center">全新</td></tr><tr><td style="text-align:center">电源</td><td style="text-align:center">鑫谷 GP1350G 1250W</td><td style="text-align:center">1</td><td style="text-align:center">680</td><td style="text-align:center">全新</td></tr><tr><td style="text-align:center">散热器</td><td style="text-align:center">爱国者（aigo）冰塔T240 极光版</td><td style="text-align:center">1</td><td style="text-align:center">299</td><td style="text-align:center">全新</td></tr><tr><td style="text-align:center">风扇</td><td style="text-align:center">金河田  光影炫光 12CM</td><td style="text-align:center">6</td><td style="text-align:center">60</td><td style="text-align:center">全新</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">12778</td><td style="text-align:center">总计</td></tr></tbody></table><p>以上就是我主机的配置清单，目前只买了一张2070，后期会升级加入多卡，下面将详细分析一下各个配件的选购过程。</p><h2 id="配件选购指南"><a href="#配件选购指南" class="headerlink" title="配件选购指南"></a>配件选购指南</h2><h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><p>有很多朋友在进行选购主机的时候认为应该先选CPU再选主板，个人认为配件选购的顺序和主机的用途是有关系的，对于搭建深度学习工作站而言，在正式进行硬件选购前，最重要的是需要确认一个问题，到底需要单卡（GPU）主机还是多卡主机，如果只需要搭建单显卡的主机，那么在选购主板的过程中，不需要花费太多精力，大量主板可以满足要求，如果想要搭建双卡、三卡或是四卡主机，则需要在主板上下点功夫，为了日后升级方便，我的目标是使用可支持四显卡的主机，所以在主板选择方面，会很注重PCIE扩展接口数量。</p><p>在初期选择主板时，网上各式各样型号的主板会使小萌新（我）很是懵逼，在网上查找了些资料，了解了些主板的知识。为了保证CPU和主板搭配合理，装到一起能正常工作，首先我们需要了解各主板芯片组和CPU接口的具体含义。例如，下图为京东的主板截图。</p><p><img src="http://pic.guoyaohua.com/1557387815846.png" alt="京东主板商品截图"></p><p>我们可以看到大多数商品名称后面都会有一个类似（AMD A320/Socket AM4）或（Intel H310/LGA 1151）的注释，其实这些就是影响你CPU和主板能否匹配的最重要参数了，在商品详情页，我们也可以找到这个参数，前面的“Intel H310”或“AMD A320”指的就是主板的芯片组，而后面的“LGA 1151”或“Socket AM4”指的就是主板上CPU插槽的类型了。</p><h4 id="芯片组"><a href="#芯片组" class="headerlink" title="芯片组"></a>芯片组</h4><p>芯片组示主板的核心芯片，选对芯片组，主板和CPU才能兼容。目前主流的主板分为Intel和AMD两个系列，分别对应不同品牌的处理器。而每个系列又按照芯片组类型的不同，分为很多子系列。以Intel系列主板为例，在市面上可以看到华硕、技嘉、七彩虹等近十个品牌的产品，不同品牌的主板在外观和技术上会有一些差别，但他们使用的芯片组都是由Intel提供的。</p><p><img src="http://pic.guoyaohua.com/intel%20chipset.jpg" alt></p><p>不过，虽然同属于Intel系列主板，但根据处理器的不同，需要搭配对应芯片组的主板才能成功组建出一台可以使用的主机。比如目前Intel最新的九代酷睿 i9-9900k 处理器需要搭配Z390、Z370或H370芯片组的主板来使用。而AMD的Ryzen 3/5/7系列CPU和APU产品则可以搭配X370、B350或A320芯片组的主板。 </p><p>那么不同芯片组的主板又有什么区别呢？有的时候，多个芯片组的主板虽然可以支持同一款处理器，但在主板的规格上还是有一定区别的。这些区别包括但不限于原生USB及磁盘接口数量、是否支持CPU超频、是否支持多显卡互联等。这对于不太了解主板的用户来说确实很难选择，简单总结一下：</p><p>B系列（如B360、B250）属于入门级产品，不具备超频和多卡互联的功能，同时接口及插槽数量也相对要少一些。<br>H系列（如H310）比B系列略微高端一些，可以支持多卡互联，接口及插槽数量有所增长。<br>Z系列（如Z390、Z370）除了具备H系列的特点支持，还能够对CPU进行超频，并且接口和插槽数量也非常丰富。<br>X系列（如X99、X299）可支持Intel至尊系列高端处理器，同时具备Z系列的各项特点。</p><p>同时，Intel的100系列和200系列主板可以搭配6代及7代酷睿处理器，300系列主板需要搭配8代酷睿处理器，X299系列主板需要搭配7代至尊系列酷睿处理器。</p><p>对于单路CPU的主板，能够同时支持四张显卡卡的神板，毫无疑问就只有X99/X299系列的主板了，当然你也可以考虑intel 服务器C系列多路CPU主板，可以支持两个CPU在一张主板上。我的目标是使用单路CPU，所以也就没有关注C系列主板。</p><p>对于X299和X99之间的选择，有的朋友会主张买新不买旧，我个人的建议还是性价比高才是好的，较新的X299板子相比X99主板要贵大几百甚至1k左右，功能上的提升并不是很大，对于我们大多数Deep Learning开发者而言，X99的板子足够了，毕竟要把钱花在刀刃上，GPU才是大手笔。X99板子主要推荐以下三款：</p><p><a href="https://www.asus.com.cn/Motherboards/X99E_WSUSB_31/" target="_blank" rel="noopener">Asus/华硕 X99-E WS/USB 3.1</a><br><img src="http://pic.guoyaohua.com/x99ews.png" alt="Asus/华硕 X99-E WS/USB 3.1"></p><p><a href="https://www.asus.com.cn/Motherboards/RAMPAGE_V_EXTREMEU31/overview/" target="_blank" rel="noopener">Asus/华硕 RAMPAGE V EXTREME/U3.1</a><br><img src="http://pic.guoyaohua.com/R5E.jpg" alt="Asus/华硕 RAMPAGE V EXTREME/U3.1"></p><p><a href="https://cn.msi.com/Motherboard/X99S-GAMING-7.html" target="_blank" rel="noopener">MSI/微星 X99S GAMING 7</a><br><img src="http://pic.guoyaohua.com/gaming7.png" alt="MSI/微星 X99S GAMING 7"></p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table><thead><tr><th style="text-align:center">型号名称</th><th style="text-align:center">MSI/微星 X99S GAMING 7</th><th style="text-align:center">华硕RAMPAGE V EXTREME/U3.1</th><th style="text-align:center">华硕X99-E WS/USB 3.1</th></tr></thead><tbody><tr><td style="text-align:center">主芯片组</td><td style="text-align:center">Intel X99</td><td style="text-align:center">Intel X99</td><td style="text-align:center">Intel X99</td></tr><tr><td style="text-align:center">CPU插槽</td><td style="text-align:center">LGA 2011-v3</td><td style="text-align:center">LGA 2011-v3</td><td style="text-align:center">LGA 2011-v3</td></tr><tr><td style="text-align:center">内存规格</td><td style="text-align:center">8×DDR4 DIMM 四通道</td><td style="text-align:center">8×DDR4 DIMM 四通道</td><td style="text-align:center">8×DDR4 DIMM 四通道</td></tr><tr><td style="text-align:center">最大内存容量</td><td style="text-align:center">128GB</td><td style="text-align:center">128GB</td><td style="text-align:center">128GB</td></tr><tr><td style="text-align:center">PCI-E标准</td><td style="text-align:center">PCI-E 3.0</td><td style="text-align:center">PCI-E 3.0</td><td style="text-align:center">PCI-E 3.0</td></tr><tr><td style="text-align:center">PCI-E插槽</td><td style="text-align:center">4×PCI-E X16 插槽</td><td style="text-align:center">5×PCI-E X16 插槽<br>1×PCI-E X1 插槽</td><td style="text-align:center">7×PCI-E X16 插槽</td></tr><tr><td style="text-align:center">存储接口</td><td style="text-align:center">10×SATA III<br>1×SATA Express<br>1×M.2（10Gb/s）</td><td style="text-align:center">1×M.2<br>2×SATA Express<br>8×SATA III</td><td style="text-align:center">1×M.2<br>2×SATA Express<br>8×SATA III<br>2×eSATA</td></tr><tr><td style="text-align:center">USB接口</td><td style="text-align:center">6×USB2.0（2背板+4内置）<br>12×USB3.0（4背板+8内置）</td><td style="text-align:center">14×USB3.0（4内置+10背板）<br>6×USB2.0（4内置+2背板）</td><td style="text-align:center">14×USB3.0（4内置+10背板）<br>4×USB2.0（4内置）</td></tr><tr><td style="text-align:center">主板板型</td><td style="text-align:center">ATX板型</td><td style="text-align:center">E-ATX板型</td><td style="text-align:center">E-ATX板型</td></tr><tr><td style="text-align:center">外形尺寸</td><td style="text-align:center">30.5×24.4cm</td><td style="text-align:center">30.5×27.2cm</td><td style="text-align:center">30.5×26.7cm</td></tr><tr><td style="text-align:center">多显卡技术</td><td style="text-align:center">NVIDIA 3-Way SLI<br> NVIDIA 3-Way SLI</td><td style="text-align:center">NVIDIA 4-Way SLI<br>AMD 4-Way CrossFireX</td><td style="text-align:center">NVIDIA 4-Way SLI<br>AMD 4-Way CrossFire</td></tr></tbody></table><p>可以看到这三款主板，均为X99芯片组，CPU插槽均为 LGA 2011-v3 ，而且有8个内存插槽，支持四通道，最高128G的内存容量，内存容量这部分个人很喜欢，对于大型数据集数据预处理的过程，对内存容量和CPU要求都很高，而且足够的内存容量使你不用再为多开窗口卡顿现象而担忧。三者都支持多显卡扩展，华硕R5E和华硕X99 E-WS均支持4显卡交火，微星X99S Gaming 7支持3显卡交火，不过显卡交火，对于深度学习计算没有任何的帮助，对游戏确是有一些提升，我们日常所说的多显卡训练模型，也不是用到交火技术，而是Data Parallel或Model Parallel，所以交火与否我们不需要关注，需要关注的时PCIE ×16扩展插槽的有效个数（有的间距太近，无法全插）。</p><p>起初最想购买的是“华硕 X99-E WS”，经典的工作站主板，很多深度学习开发者的首选，支持四路显卡交火，更为优秀的是竟然有7个×16全速PCIE 3.0扩展插槽，但是对于这类主板虽然有如此强大的扩展功能，但在真正插显卡的时候，由于PCIE接口之间的空间限制，你是无法插满插槽的，而且现在显卡都很厚，很可能会造成接口的浪费。这个板子已经停产，不过在天猫的华硕旗舰店仍然有存货，售价“3899元”，还是很贵的。其中有很多功能，对于我们日常使用、训练模型来讲并不是很用得上，会造成没必要的开销。最后我选择了在淘宝购买二手的“华硕 RAMPAGE V EXTREME”，毕竟便宜。如果经费充足的朋友，我仍然建议购买“华硕 X99 E-WS”这个主板。</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>对于CPU的选取是基于确定主板CPU插槽类型为前提的，例如我们上文中我们选择的X99系列三款主板，CPU插槽类型均为“LGA 2011-v3”，我们就要选与此匹配的CPU，各插槽类型的CPU具体有哪些型号，可以去<a href="http://detail.zol.com.cn/cpu/" target="_blank" rel="noopener">中关村在线</a>查询，里面还有一些性能测评的文章和排行榜信息，值得推荐。</p><p>为了能够为CPU做出明智的选择，我们首先需要了解CPU以及它与深度学习的关系。CPU为深度学习做了什么？当你在GPU上运行深度网络时，CPU几乎不会进行任何计算。它主要的作用是：（1）启动GPU函数调用，（2）执行CPU函数。</p><p>CPU对于数据预处理的过程却起重要作用。有两种常见的数据处理策略，它们具有不同的CPU需求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一、在训练时进行数据预处理</span></span><br><span class="line"><span class="keyword">for</span> train_step <span class="keyword">in</span> range(tot_train_step):</span><br><span class="line">    load_mini_batch()</span><br><span class="line">    preprocess_mini_batch()</span><br><span class="line">    train_on_mini_batch()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二、在训练前进行数据预处理</span></span><br><span class="line">preprocess_data()</span><br><span class="line"><span class="keyword">for</span> train_step <span class="keyword">in</span> range(tot_train_step):</span><br><span class="line">    load_preprocessed_mini_batch()</span><br><span class="line">    train_on_mini_batch()</span><br></pre></td></tr></table></figure><p>对于第一个策略，为避免CPU的性能成为训练模型的速度的瓶颈，具有高主频多内核的CPU可以显著提高性能，加快训练速度。对于第二种策略，由于是预先进行数据预处理，在训练时的速度取决于GPU性能，与CPU无关，理论上CPU的性能不会成为瓶颈。但是我个人的观点还是，在经费允许的情况下，尽管CPU的性能越强大越好，但是也不一定非要追求最新款、最强大的CPU，性价比和个人需求才是最关键的。</p><blockquote><p>当然，此处附加一点说明，如果攒机后不仅需要训练模型，而且偶尔也会玩一些游戏消遣的话，尽量选择高主频的主机，志强系列多核心低主频CPU不适合游戏玩家。</p></blockquote><h4 id="PCIe-通道"><a href="#PCIe-通道" class="headerlink" title="PCIe  通道"></a>PCIe  通道</h4><p>CPU的PCIe通道对模型训练的影响网上也纵说纷云，首先让我们先了解一下什么是CPU的PCIe通道</p><blockquote><p><a href="https://baike.baidu.com/item/PCI-Express" target="_blank" rel="noopener">PCI-Express</a>(peripheral component interconnect express)是一种高速串行计算机扩展总线标准，它原来的名称为“3GIO”，是由<a href="https://baike.baidu.com/item/英特尔/305730" target="_blank" rel="noopener">英特尔</a>在2001年提出的，旨在替代旧的PCI，PCI-X和AGP总线标准。PCIe属于高速串行点对点双通道高带宽传输，所连接的设备分配独享通道带宽，不共享总线带宽，主要支持主动电源管理，错误报告，端对端的可靠性传输，热插拔以及服务质量(<a href="https://baike.baidu.com/item/QOS" target="_blank" rel="noopener">QOS</a>)等功能。</p></blockquote><p>简而言之，PCIe通道就是主机中各组件进行数据交互的信道，PCIe通道分两种：</p><ol><li>CPU直连通道，主流消费级只给你16条(8700K)，高端&amp;服务器上才会多给(7980XE)。</li><li>DMI3总线PCH芯片分发出来的，是主板的属性。例如Z370主板声称有24条PCIE通道，其实这24条就是PCH通道，要共享DMI3等效直连PCIe ×4的带宽。</li></ol><p>就PCH而言，在很多高性能扩展面前没有智联通道强大，所以对于CPU的直连通道数就显得至关重要了。</p><p>Tim Dettmers大神在他的博文《<a href="https://timdettmers.com/2018/12/16/deep-learning-hardware-guide/" target="_blank" rel="noopener">A Full Hardware Guide to Deep Learning</a>》中也做出了对PCIe通路的见解，Tim认为在单机少量（小于4）GPU的主机中，PCIe通路对模型训练的影响并不是很大，但对于大于4个GPU或GPU集群PCIe通路的影响就会很显著。在文章中，Tim对比了不同通道数量在模型训练过程中的速度传输速度对比。</p><blockquote><p><strong>CPU and PCI-Express</strong></p><p>People go crazy about PCIe lanes! However, the thing is that it has almost no effect on deep learning performance. If you have a single GPU, PCIe lanes are only needed to transfer data from your CPU RAM to your GPU RAM quickly. However, an ImageNet batch of 32 images (32x225x225x3) and 32-bit needs 1.1 milliseconds with 16 lanes, 2.3 milliseconds with 8 lanes, and 4.5 milliseconds with 4 lanes. These are theoretic numbers, and in practice you often see PCIe be twice as slow — but this is still lightning fast! PCIe lanes often have a latency in the nanosecond range and thus latency can be ignored.</p><p>Putting this together we have for an ImageNet mini-batch of 32 images and a ResNet-152 the following timing:</p><ul><li>Forward and backward pass: 216 milliseconds (ms)</li><li>16 PCIe lanes CPU-&gt;GPU transfer: About 2 ms (1.1 ms theoretical)</li><li>8 PCIe lanes CPU-&gt;GPU transfer: About 5 ms (2.3 ms)</li><li>4 PCIe lanes CPU-&gt;GPU transfer: About 9 ms (4.5 ms)</li></ul><p>Thus going from 4 to 16 PCIe lanes will give you a performance increase of roughly 3.2%. However, if you use <a href="https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader" target="_blank" rel="noopener">PyTorch’s data loader</a> with pinned memory you gain exactly 0% performance. So do not waste your money on PCIe lanes if you are using a single GPU!</p><p>When you select CPU PCIe lanes and motherboard PCIe lanes make sure that you select a combination which supports the desired number of GPUs. If you buy a motherboard that supports 2 GPUs, and you want to have 2 GPUs eventually, make sure that you buy a CPU that supports 2 GPUs, but do not necessarily look at PCIe lanes.</p><p><strong>PCIe Lanes and Multi-GPU Parallelism</strong></p><p>Are PCIe lanes important if you train networks on multiple GPUs with data parallelism? I have <a href="https://arxiv.org/abs/1511.04561" target="_blank" rel="noopener">published a paper on this at ICLR2016</a>, and I can tell you if you have 96 GPUs then PCIe lanes are really important. However, if you have 4 or fewer GPUs this does not matter much. If you parallelize across 2-3 GPUs, I would not care at all about PCIe lanes. With 4 GPUs, I would make sure that I can get a support of 8 PCIe lanes per GPU (32 PCIe lanes in total). Since almost nobody runs a system with more than 4 GPUs as a rule of thumb: Do not spend extra money to get more PCIe lanes per GPU — it does not matter!</p></blockquote><p>不过依我个人的看法，还是要选支持PCIe通道数大一点的CPU，毕竟M.2 NVME SSD就会占据四条通道，如果我们CPU只支持16通道，并且有两个GPU的话，每个GPU只能分到×4的速度，这个总感觉不太好。显卡已经花了那么多钱，我们当然希望它能全速跑，不要由于CPU PCIe通路的短板影响整体的性能，得不偿失。所以我更倾向于选择40条通路的CPU。目前主流CPU大多支持16通道、24通道，对于至尊系列CPU会有支持40通道的，对于大部分志强系列服务器CPU大多数支持44通道。</p><h4 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h4><p>对于志强系列，网上所有渠道都基本是拆机CPU，很多是外国服务器淘汰下的CPU，质量方面，由于没有使用过，不妄加评论。志强系列U特点是核心多，单核主频低，如果对于高并发有需求的朋友，可以优先选择志强系列U，搭配双路服务器主板。但对于我个人来讲，对单核主频要求高一些，所以我更倾向于桌面级CPU。</p><p>在我选择CPU的过程中，<a href="https://diy.pconline.com.cn/tiantitu/cpu/" target="_blank" rel="noopener">CPU天梯图</a>对我很有帮助，很直观的展现了Intel/AMD所有CPU的性能排行，也推荐给大家。</p><p><img src="http://pic.guoyaohua.com/cputianti.png" alt="CPU天梯图"></p><p>经过反复的对比，最终锁定了两款CPU“i7-6850K”和“i7-6950X”，首先首先我先解释一下为什么没有选择最新的九代酷睿系列，目前九代酷睿发布没多久，例如“I9-9900K”也是炒的很火热， 虽然最新系列的CPU单核主频都有所提高，但是核心数并没有太大改善，致使CPU整体性能（多核性能）并不是越新越好，从上方的天梯图我们也可以看出，“I7-6950X”排在”I9-9900K”前面，第二个原因就是，CPU是一个没什么损耗的器件，如果没有变态超频使用的话，全新和二手的U新能没什么区别，对于这些已经停产的CPU，网上流通的都是拆机的二手版本，只要选择正式版（不要<a href="http://www.lotpc.com/yjzs/6996.html" target="_blank" rel="noopener">QS/ES版本</a>），其实都可以的，而且价格便宜，性价比极高，例如我们Intel官网可以看到“i7-6950X”的官方报价为￥11053.74，上万元！</p><p><img src="http://pic.guoyaohua.com/intel6950x.png" alt="6950X官网"></p><p>而在淘宝等渠道购买的正式版I7-6950X散片，只有3400元，价格差距如此之大。对于这种旧款CPU的散片（正式版）性价比还是蛮高的，所以推荐大家购买散片CPU（当然也会有很多朋友担心散片CPU的质量问题，这个确实不能保证每个渠道的U都是好的，看人品吧~）。下面对比一下“i7-6850K”、“I7-6950X”、“i75960X”以及“I7-6900K”这几款CPU。</p><table><thead><tr><th style="text-align:center">基本要素</th><th style="text-align:center"><a href="https://www.intel.cn/content/www/cn/zh/products/processors/core/x-series/i7-6950x.html" target="_blank" rel="noopener">酷睿™ i7-6950X</a></th><th style="text-align:center"><a href="https://www.intel.cn/content/www/cn/zh/products/processors/core/x-series/i7-6850k.html" target="_blank" rel="noopener">酷睿™ i7-6850K</a></th><th style="text-align:center"><a href="https://www.intel.cn/content/www/cn/zh/products/processors/core/x-series/i7-5960x.html" target="_blank" rel="noopener">酷睿™ i7-5960X</a></th><th style="text-align:center"><a href="https://www.intel.cn/content/www/cn/zh/products/processors/core/x-series/i7-6900k.html" target="_blank" rel="noopener">酷睿™ i7-6900K</a></th></tr></thead><tbody><tr><td style="text-align:center">发行日期</td><td style="text-align:center">Q2’16</td><td style="text-align:center">Q2’16</td><td style="text-align:center">Q3’14</td><td style="text-align:center">Q2’16</td></tr><tr><td style="text-align:center">光刻</td><td style="text-align:center">14 nm</td><td style="text-align:center">14 nm</td><td style="text-align:center">22 nm</td><td style="text-align:center">14 nm</td></tr><tr><td style="text-align:center">内核</td><td style="text-align:center">10</td><td style="text-align:center">6</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">线程</td><td style="text-align:center">20</td><td style="text-align:center">12</td><td style="text-align:center">16</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">基本频率</td><td style="text-align:center">3.00 GHz</td><td style="text-align:center">3.60 GHz</td><td style="text-align:center">3.00 GHz</td><td style="text-align:center">3.20 GHz</td></tr><tr><td style="text-align:center">睿频频率</td><td style="text-align:center">3.50 GHz</td><td style="text-align:center">3.80 GHz</td><td style="text-align:center">3.50 GHz</td><td style="text-align:center">3.70 GHz</td></tr><tr><td style="text-align:center">缓存</td><td style="text-align:center">25 MB</td><td style="text-align:center">15 MB</td><td style="text-align:center">20 MB</td><td style="text-align:center">20 MB</td></tr><tr><td style="text-align:center">TDP</td><td style="text-align:center">140 W</td><td style="text-align:center">140 W</td><td style="text-align:center">140 W</td><td style="text-align:center">140 W</td></tr><tr><td style="text-align:center">最大内存</td><td style="text-align:center">128 GB</td><td style="text-align:center">128 GB</td><td style="text-align:center">64 GB</td><td style="text-align:center">128 GB</td></tr><tr><td style="text-align:center">内存类型</td><td style="text-align:center">DDR4 2400/2133</td><td style="text-align:center">DDR4 2400/2133</td><td style="text-align:center">DDR4 1600/1866/2133</td><td style="text-align:center">DDR4 2400/2133</td></tr><tr><td style="text-align:center">内存通道</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">PCIe通道</td><td style="text-align:center">40</td><td style="text-align:center">40</td><td style="text-align:center">40</td><td style="text-align:center">40</td></tr></tbody></table><p>可以看到，四者均支持40条直通PCIe通道，当主板支持四路交火时，以“华硕RAMPAGE V EXTREME”为例，四张显卡分别占用（×8，×8，×8，×8）的速度，不会对性能产生太大影响。“I7-5960X”仅支持最高64GB的内存容量，这个对于我们的板子就略显不足了，相比“I7-6850K”和“I7-6900K”，在单核主频方面6850k基本频率为3.60GHz高于6900K的3.20GHz，不过核心数却没有胜出，二者基本属于同一等级的CPU，整体性能6900K略高于6850K，不过从性价比方面来看（散片），6850K的性价比还是略高的，散片售价仅2500元左右。“I7-6950X”是这几款U中性能最强劲的，虽然单核主频只有3.00GHz但是10核心20线程使其整体性能遥遥领先，可以从上文中的CPU天梯图中看到，尽管这个U是16年推出的，不过在当日的排行版也能排列到十几名，表现还是很出色的，唯一的不足就是价格略显昂贵，散片价格为3400元，之前一直想买2500元的6850K，后来一咬牙买了6950X。</p><p><img src="http://pic.guoyaohua.com/6950X_.jpg" alt="I7-6950X散片"></p><p>总之，在选购CPU时，建议需要以下顺序：</p><ol><li>筛选与主板插槽类型匹配的CPU。</li><li>查看<a href="https://diy.pconline.com.cn/tiantitu/cpu/" target="_blank" rel="noopener">CPU天梯图</a>，了解CPU的整体性能排序。</li><li>在intel官网上将预选出的商品进行详细参数对比。</li><li>淘宝、京东对比散片价格，考虑入手性价比高的U。</li></ol><blockquote><p>个人建议：由于CPU这个东东如果正常使用基本没什么损耗，在选购散片时，会发现各个商家价格会有所差别，其实不一定要买最贵的，价格的不同可能是由于商家进货渠道引起的，只要认准“正式版”即可，避开“QS/ES”版本。</p></blockquote><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存是相对好选的组件，就没有必要多说了，以我个人来看，当然容量越大越好，毕竟现在内存价格低谷，抓紧买！</p><p>建议“海盗船复仇者”系列，我在选购内存的时候，基本把淘宝翻了个遍，看了很多厂家，价格都很贵，而且有很多都是小厂。对于海盗船复仇者系列内存，很多DIY玩家的首选，也不是没有原因的，现在一条16G的台式内存，只卖不到500元，很是便宜！而且口碑一直不错。</p><p><img src="http://pic.guoyaohua.com/Vengeance_LPX_DDR4_BOX.png" alt="海盗船 复仇者系列"></p><h4 id="频率"><a href="#频率" class="headerlink" title="频率"></a>频率</h4><p>目前市场上的内存大多在频率上做了很多营销手段，我们可以看到（2133 MHz、2400MHz、3000MHz、3200MHz以至于更高）的内存频率，同容量不同频率的内存条价格也相差很多，贵几百元的都有。但是我们是否有必要追求高频率的内存呢？</p><p>经过阅读网上一些大牛的文章，大多数人的观点都是，RAM频率对性能方面没有明显的提升，尤其是在做深度学习方面。其实频率只是各个厂商的一种营销手段，RAM公司会引诱大家购买“更快”的内存，其性价比并不高。有追求频率的钱，还不如多加一条内存。此处可参阅“<a href="https://www.youtube.com/watch?v=D_Yt4vSZKVk" target="_blank" rel="noopener">Does RAM speed REALLY matter?</a>” </p><p>所以我入手了“海盗船 复仇者”系列单条16GB最便宜的内存<strong>2400 MHz</strong>，一共上了4条，总共64GB。主板有8个内存插槽，先插四条构成四通道，剩余的留作扩展，不过此处一定注意， 在安装内存条的时候需要阅读主板说明书，基本每个主板都会给出推荐的插法，看好个插槽所在的通道，一定不要插错了。</p><h3 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h3><p>在初期选购固态硬盘的朋友可能会经常看到SATA3固态硬盘与M.2固态硬盘，可能有朋友会有疑问：M.2是什么意思？和SATA3固态硬盘有什么区别？下面我们就简单科普M.2接口。</p><p><img src="http://pic.guoyaohua.com/M.2SSD.jpg" alt="img"></p><h4 id="M-2接口"><a href="#M-2接口" class="headerlink" title="M.2接口"></a>M.2接口</h4><p>M.2是一种固态硬盘新接口，是Intel推出的一种替代MSATA新的接口规范，也就是我们以前经常提到的NGFF，英文全称为：Next Generation Form Factor。</p><p>M.2接口固态硬盘主要优势在于体积相比传统的SATA3.0、MSATA更小，并且读取速度更快，对于一些移动设备兼容性更好。</p><ul><li>M.2和SATA3固态硬盘的区别</li></ul><p>目前固态硬盘（SSD）常用的接口主要有3种：</p><ol><li><strong>SATA3</strong> - 外形尺寸是2.5寸硬盘的标准尺寸，与2.5寸机械硬盘可以互换。</li><li><strong>mSATA</strong> - 接口尺寸与笔记本内置无线网卡相同，不过mSATA SSD的外形尺寸比无线网卡更大。</li><li><strong>M.2</strong> - 初期称为NGFF接口，是近两年新出的接口，为专门为超小尺寸而设计的，使用PCI-E通道，体积更小，速度更快。</li></ol><p>值得一提的是<strong>M.2接口固态硬盘又分为：SATA和PCI-E两种，虽说长得一模一样，但性能却是差之千里</strong>。此外，有些主板的M.2接口不一定对其支持，所以在买M.2固态硬盘的时候，还需要了解下接口兼容性，在购买主板和SSD时关注一下接口信息即可。</p><p>M.2有两种接口定义：Socket 2和Socket 3。Socket 2支持SATA或PCIe ×2通道的SSD，Socket 3专为高性能存储设计，支持PCIe ×4通道。在购买SSD时一定要确认是否走PCIe  ×4通道，这样才性能最佳。</p><h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p>在容量方面，大多数用户512G就够用了，毕竟SSD不是作为数据存储盘使用，而是作为系统盘安装程序使用，但由于目前SSD价格下滑，决定还是入手一个1T的，这样更充足。</p><p>经过仔细挑选，最终筛选出两款SSD，“Samsung/三星 MZ-V7S1T0BW 970 EVO Plus 1TB”和“WD/西部数据 WDS100T2X0C 1TB”，比较推荐三星这款，三星的固态一直是业界最好的，速度最快的，不过西数的SSD也在第一梯队，二者价格相差300元左右，“三星970 EVO Plus”速度略高于“西数WDS100T2X0C”，官方宣传三星这款读取速度3500Mb/s、写入速度3300Mb/s，西数这款读取速度3400Mb/s、写入速度2800Mb/s，如果经费允许的朋友推荐三星这款，不过我选择了较为便宜的西数SSD。其他品牌的没用过，不能妄加评论，但是三星和西数的固态硬盘一定是第一梯队了。</p><h3 id="机械硬盘"><a href="#机械硬盘" class="headerlink" title="机械硬盘"></a>机械硬盘</h3><p>机械硬盘容量视个人情况而定，对于计算机视觉工程师，如果需要存放大体积数据集，就买大一点的，毕竟HDD不贵（但一定记住避开希捷、避开希捷、避开希捷！之前笔记本加装过希捷硬盘，太渣了）。我最后入手了“西部数据 WD40EZRZ 4TB 蓝盘”，买的OEM版本，比官方价格低100多，用着还不错。</p><h3 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h3><p>显卡的选择，Tim Dettmers的《<a href="https://timdettmers.com/2019/04/03/which-gpu-for-deep-learning/" target="_blank" rel="noopener">Which GPU(s) to Get for Deep Learning: My Experience and Advice for Using GPUs in Deep Learning</a>》一文已经分析的非常透彻，我也是参考了他的文章购置了RTX 2070显卡，各位朋友可以深入阅读该文章，此处只做简要阐述。</p><h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><p><img src="http://pic.guoyaohua.com/performance_RTX.png" alt></p><p>GPU和TPU的标准化性能数据。越高越好。RTX卡使用16位计算。使用PyTorch 1.0.1和CUDA 10完成基准测试。</p><h4 id="性价比分析"><a href="#性价比分析" class="headerlink" title="性价比分析"></a>性价比分析</h4><p><img src="http://pic.guoyaohua.com/performance_per_dollar_RTX.png" alt></p><p>卷积网络（CNN），循环网络（RNN）和Transformer的性能/价格。越高越好。RTX 2060的成本效率是Tesla V100的5倍以上。使用PyTorch 1.0.1和CUDA 10完成基准测试。</p><blockquote><p>注：以上图转载自《<a href="https://timdettmers.com/2019/04/03/which-gpu-for-deep-learning/" target="_blank" rel="noopener">Which GPU(s) to Get for Deep Learning: My Experience and Advice for Using GPUs in Deep Learning</a>》</p></blockquote><p>经过Tim的分析，更倾向于购买RTX 20系列显卡，因为其独有的“Tensor core”可以支持加速FP16的运算，减少显存的支出，也能减少计算复杂度，</p><h4 id="整体建议（转载）"><a href="#整体建议（转载）" class="headerlink" title="整体建议（转载）"></a>整体建议（转载）</h4><blockquote><p><strong>最佳GPU</strong>：RTX 2070<br><strong>避开GPU</strong>：任何Tesla; 任何Quadro卡;  Titan RTX，Titan V，Titan XP<br><strong>实惠但价格昂贵</strong>：RTX 2070经济<br><strong>实惠且价格便宜</strong>：RTX 2060，GTX 1060（6GB）。<br><strong>我有点钱</strong>：GTX 1060（6GB）<br><strong>我几乎没有钱</strong>：GTX 1050 Ti（4GB）。或者：CPU（原型设计）+ AWS / TPU（训练）; 或者Colab。<br><strong>我做Kaggle：RTX 2070</strong><br><strong>计算机视觉或机器翻译研究员</strong>：GTX 2080 Ti，如果您训练非常大的网络获得RTX Titans。<br><strong>NLP研究员</strong>：RTX 2080 Ti使用16位。<br><strong>我开始深入学习并且我认真对待它</strong>：从RTX 2070开始。在6-9个月之后购买更多RTX 2070并且您仍然希望投入更多时间进行深度学习。根据您接下来选择的区域（启动，Kaggle，研究，应用深度学习），销售GPU并在大约两年后购买更合适的东西。<br><strong>我想尝试深度学习，但我并不认真</strong>：GTX 1050 Ti（4或2GB）。这通常适合您的标准桌面，不需要新的PSU。如果它适合，不要购买新电脑！</p></blockquote><h4 id="选购"><a href="#选购" class="headerlink" title="选购"></a>选购</h4><p>看了Tim给出的建议，我最终选择了RTX 2070显卡，虽然只有8G显存，不过使用16位运算，主流网络也都能跑起来。对于品牌的选购我只建议<strong>不要买灯效、不要买超频</strong>，你要相信一点，同一个型号的显卡（例如RTX 2070），任何厂家任何款式的商品在性能上均没有什么性能差距，价格差距主要体现在所谓的超频、灯光效果上，我个人的建议是完全没有必要把钱花费在这上面，关注一下散热，一线厂商的用料都不会太差。</p><p>我选购了“影驰 RTX2070 大将”，3400元。对于经费充裕的朋友，RTX 2080 Ti也是一个非常好的选择，我之后扩展可能会入手2080 Ti</p><p><img src="http://pic.guoyaohua.com/rtx2070.jpg" alt="影驰 RTX2070 大将"></p><h3 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h3><p>通常，我们需要一个足以容纳所有未来GPU的电源。电源的稳定性也对组件的寿命有很大影响，因此购买一个优质的电源是很有意义的。</p><p>因为一个主机最终要的功耗组件是GPU和CPU，我们可以通过将CPU和GPU的功耗累加，并且附加其他组件大约额外10％W来计算所需的功率。网上也有很多计算功率的网站，但大多组件不是很全面，没有什么参考价值， 我的建议就是尽量上大功率电源，留作之后升级显卡使用。还要注意，模组电源支持的PCIE口数量，例如上面我所购买的RTX2070影驰大将，电源接口为8+6pin的，占用默许电源两个8pin的PCIe供电口，如果电源给的供电口只有6个8pin供电口，那么我们只能给3张显卡供电。这个问题需要注意一下。</p><p><img src="http://pic.guoyaohua.com/psu.png" alt="电源"></p><p>对于电源，我有两款产品推荐：“鑫谷GP1350G 额定1250W 全模组”和“长城巨龙服务器电源 1250W 全模组”，二者价格差不多，我买的鑫谷这款。</p><h3 id="散热器"><a href="#散热器" class="headerlink" title="散热器"></a>散热器</h3><p>CPU散热部分，之前一直想上一个风冷节省支出，但是由于I7-6950X已经140W了，风冷根本压不住，所以上了240双冷排的水冷，在选购散热器时注意与商家咨询该散热器是否能压住该功率CPU。我入手的“爱国者（aigo）冰塔T240 极光版”，散热效果很好。</p><h3 id="机箱"><a href="#机箱" class="headerlink" title="机箱"></a>机箱</h3><p>机箱看个人喜好吧，尽量大一点，散热能好些。我入手的“爱国者（aigo）月光宝盒 破晓”。</p><h3 id="风扇"><a href="#风扇" class="headerlink" title="风扇"></a>风扇</h3><p>风扇这个东西还挺贵的，普通的大约20多一个，真是不明白贵在哪里，购买风扇踩了个坑，以为各种风扇都一样，买便宜的就好，入手了京东最便宜的风扇10元一个，看标注风力之类的都比爱国者极光好，但是实测风力没有爱国者极光风扇强大，不过极光风扇噪音有点大。</p><p><img src="http://pic.guoyaohua.com/fan.png" alt="机箱风扇"></p><h2 id="组装"><a href="#组装" class="headerlink" title="组装"></a>组装</h2><p>装机部分随便上张图意思一下吧~总之是忙了一整天才弄好。</p><p><img src="http://pic.guoyaohua.com/zhuangji.jpg" alt="装机"></p><p><img src="http://pic.guoyaohua.com/%E4%B8%BB%E6%9C%BA%E6%AD%A3%E9%9D%A2%E5%9B%BE.jpg" alt></p><p><img src="http://pic.guoyaohua.com/%E4%B8%BB%E6%9C%BA%E4%BE%A7%E9%9D%A2%E5%9B%BE.jpg" alt></p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p><img src="http://pic.guoyaohua.com/ludashi.jpg" alt></p><p><img src="http://pic.guoyaohua.com/cpu-z1.png" alt></p><p><img src="http://pic.guoyaohua.com/AIDA.png" alt></p><p><img src="http://pic.guoyaohua.com/ssd.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;接触深度学习已经快两年了，之前一直使用&lt;a href=&quot;https://colab.research.google.com&quot; target=
      
    
    </summary>
    
      <category term="DeepLearning" scheme="http://www.guoyaohua.com/categories/DeepLearning/"/>
    
    
      <category term="DeepLearning" scheme="http://www.guoyaohua.com/tags/DeepLearning/"/>
    
  </entry>
  
</feed>
